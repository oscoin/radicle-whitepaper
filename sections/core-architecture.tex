\section{Core Architecture}

In order to represent partial as well as totally ordered operations, \oscoin{}
employs a treelike data-structure which we shall refer to as the ``block-tree''.
Our block-tree starts from a \emph{root} chain and splits into sub-chains
we refer to as \emph{branches}.  Operations on the tree are represented by
cryptographically linked blocks of transactions (``blockchains''), with the most
recent block in any given branch known as the tip of the branch, or \emph{leaf}.

This design affords us several advantages over traditional blockchains, namely
the freedom to incorporate causally-ordered transactions within the semantics
of the protocol, as well as the ability to define semantics on a per-branch
basis, as we shall see in \S~\ref{fold-function}.

\subsection{Genesis}

The first block of any chain $C$ is called the \emph{genesis}. Within the
genesis, the semantics of the chain are defined by a fold function $\fold$ and
an initial state $\state_0$ known as the genesis state. Though $\fold$ is part
of $\state$, we shall sometimes refer to them separately for emphasis.  We can
thus describe the genesis block of a chain, $C_{gen}$ minimally as
\[
    C_{gen} \equiv \tuple{C_{\fold}, C_{\state_0}}.
\]

\subsection{The $\Upsilon$ Function} \label{fold-function}

Describing the semantics of a chain $C$ is done via implementing $C_{\fold}$.
To understand why, we describe the state $\state_{h+1}$ of a chain after
applying a sequence of transactions $t_1 \dots t_n$ as the the recursive application of $\fold$:
\[
    (\state_{h+1}, \fold') \equiv \apply(\cdots \apply(\apply(\apply(\state_h,
    t_1), t_2), t_3) \cdots t_n).
\]
Since $\fold$ is defined within $\state$, $\fold$ is also able to amend itself as
part of this state transition.

\subsection{The Root}
In the beginning, we have only one chain, known as the \emph{root}. In its simplest
form, the genesis of the root chain would be defined as an empty state $\varnothing$
and a fold function $f$ which allows only one operation called $branch$, which takes
an identifier, a fold function of its own and creates a branch with the given
fold function as $\fold$.
