\section{Core Architecture}

% TODO: Reference Tezos.
% TODO: Reference Holochain.
% TODO: Reference Snowflake?
% TODO: Reference Scuttlebut.

In order to represent partial as well as totally ordered operations over the
network, \oscoin{} employs a DAG-like data-structure which we shall refer to as
the ``block-tree''.  Our block-tree starts from a \emph{root} chain and splits
into sub-chains via a process called branching. We thus refer to the sub-chains as
\emph{branches}.  Operations on the tree are represented by cryptographically
linked blocks of transactions (``blockchains''), with the most recent block in
any given branch known as the tip of the branch, or \emph{leaf}.

This design affords us several advantages over traditional blockchains, namely
the freedom to incorporate partially-ordered transactions within the semantics
of the protocol, as well as the ability to define semantics on a per-chain
basis, as we shall see in \S~\ref{fold-function}.

\todo{Motivate this architecture better?}

% TODO: Motivate. Basically, same thesis as Tezos, but
% done differently, with code on-chain. Also allows governance to change
% validation functions, which you can't do otherwise.
% Mimics the branching model of VCSs.

% * Partial ordering
% * Self-amending
%   * Governance (code on-chain)
%   * Protocol upgrade (semantics only)
% * Single writer
%   * Instant-finality
%   * Offline capable
%   * Agent-based
% * Scalability
%   * Logical sharding
%   * Selective syncing (following)

\subsection{Overview}

The first block of any chain is called the \emph{genesis}. We represent a chain
$C$ as a sequence of blocks $B_0 \dots B_h$ where $B_0$ is the genesis,
$B_h$ is the leaf, and $h$ is the height of $C$. Within the genesis, the
semantics of a chain is defined by an initial state $S_0$ known as the
genesis state. The state of all chains is collectively known as the root state
$\state$ which represents a hierarchy of states starting from the root
and descending into the state of each branch.

\subsection{State}

The state $S$ of a chain can be defined as a function mapping a key $k \in K$ to a
value $v$. We define the special form $S[k]$ as:
\[
    S[k] \equiv \begin{cases}
        v                   & \text{if} \quad k \in K \\
        \bot                & \text{otherwise}
    \end{cases}
\]

\subsection{The $\fold$ Function} \label{fold-function}

Within its target set, $S$ contains a value $S[\fold]$ or more succinctly
$\fold$ which describes how $S$ is to be interpreted. This recursive definition
of $S$ and $\fold$ is key to implementing a self-describing and self-amending
chain. Formally, we define $\fold$ as a function
\[
    \fold : (\env, t) \mapsto \env',
\]
where $\env$ is a given execution environment, $t$ is an operation to be
evaluated within that environment, and $\env'$ is the resulting environment
after applying $\fold$.  In the context of a chain $C$, we can say that $\env
\equiv S$ and describe the state $S_{h+1}$ of $C$ after applying a
sequence of transactions $t_1 \dots t_n$ as the recursive application of $\fold$:
\[
    S_{h+1} \equiv \apply(\cdots \apply(\apply(\apply(S_h,
    t_1), t_2), t_3) \cdots t_n).
\]

Since $\fold$ is defined within $S$ as $S[\fold]$, $\fold$ is also
able to amend itself as part of this state transition, and so we can say that:
\[
    \exists t \in \mathcal{T} : \fold(S, t)[\fold] \neq \fold,
\]
where $\mathcal{T}$ is the set of transactions recognized by $\fold$.  Note
that $t$ is not defined as part of the base protocol. Instead $t$ is
interpreted by the fold function $\fold$, and its semantics entirely determined
by it. This gives $\fold$ complete flexibility, as we shall see in
\S~\ref{s:root}.

\subsection{The Block-Tree}

So far we've talked about single chains with a state $S$ and fold function
$\fold$, but our architecture notably allows chains to form a tree structure,
via \emph{branching}. This ``block-tree'' is represented formally as a set
$\tree$ of chains, where every chain $C \in \tree$ is either the parent of a
chain, its descendant, or a sibling. When a chain $C'$ branches off its parent
chain $C$, we denote this as $C \prec C'$.

Though there is a clear hierarchy between the branches, blocks are allowed to
refer to an arbitrary number of parents, making the ``block-tree'' exhibit the
properties of a DAG.

\todo{Transition.}

\subsubsection{The Root and Radicle}
\label{s:root}

In the beginning, we have only one chain, known as the \emph{root}, with a
single block, the \emph{radicle}. This initial state, which is effectively the
genesis of the first chain is the ancestor of all branches, and is the only
block with no parent.

Besides having no parent, the radicle is special in that it is applied to the
genesis root state $\state_0$ by the genesis fold $\fold_{0}$. This particular
fold is defined as:
\[
    \fold_{0} \equiv (\env, t) \mapsto \eval (\env, t),
\]
or more succinctly,
\[
    \fold_0 \equiv \eval,
\]
where $\eval$ is the \emph{eval} function of some interpreted language $L$.
Thus, at genesis, $t$ can be any valid expression in $L$, effectively giving
the root chain the properties of a read-eval loop, where the resulting
environment after evaluation is carried to the next block.

\todo{Something about "This programming environment can be used to..."} \\
\todo{Reference lisp/scheme?} \\
\todo{read-eval-commit loop?}

\subsubsection{Branching}

In every block header there is what we call a \emph{chain-id}. This identifier,
formally $H_{id}$ is used by the protocol to understand the intent of a block;
to decide what to do with it in the case where more than one block exists with
the same parent hash.

Let $A$, $B$ and $B'$ be blocks considered by the protocol where $A \prec B
\wedge A \prec B'$.  Let $b$ be the chain-id of $B$,  $b'$ be the chain-id of
$B'$, $a$ be the chain-id of $A$, and $b \neq b'$. There are two scenarios
that come to play assuming only valid blocks.

\begin{enumerate}
    \item If $b = a$ and $b' = a$, then $B$ and $B'$ are in \emph{conflict}.
        This means only one of the two will be chosen to succeed $A$. To
        resolve this, the protocol uses the \textsc{score} function discussed
        in \S~\ref{consensus} to decide which block to build upon.
    \item If $b \neq a$ or $b' \neq a$, then we have a \emph{branch}. The block
        or blocks which do not have a matching chain-id with their parent $A$
        will consistute a new chain with new chain-id. This new chain will
        exist alongside $A$'s chain, and will share an ancestry or ``prefix''
        with $A$.
\end{enumerate}

This simple rule means that the only difference between a chain and its branches
is the chain-id, and to create a branch, one needs only to submit a block with
a unique chain-id.

\todo{Talk about following chains.} \\
\todo{Talk about having to read chains all the way up to the ancestor's genesis.} \\
\todo{As you go up, the chain-id changes because all chains except the root are branches.} \\
\todo{Another way to follow a chain is to start from a leaf and follow it up to its genesis.}

% TODO: Diagram for this ^

