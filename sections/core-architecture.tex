\section{Core Architecture}

In order to represent partial as well as totally ordered operations over the
network, \oscoin{} employs a DAG-like data-structure which we shall refer to as
the ``block-tree''.  Our block-tree starts from a \emph{root} chain and splits
into sub-chains via a branching operation. We thus refer to the sub-chains as
\emph{branches}.  Operations on the tree are represented by cryptographically
linked blocks of transactions (``blockchains''), with the most recent block in
any given branch known as the tip of the branch, or \emph{leaf}.

This design affords us several advantages over traditional blockchains, namely
the freedom to incorporate partially-ordered transactions within the semantics
of the protocol, as well as the ability to define semantics on a per-chain
basis, as we shall see in \S~\ref{fold-function}.

% TODO: Should we call the combination of state and fold the 'environment'?

\subsection{Genesis}

The first block of any chain $C$ is called the \emph{genesis}. We represent
chains as a sequence of blocks $C \equiv B_0 \dots B_h$ where $B_0$ is the
genesis, $B_h$ is the leaf, and $h$ is the height of $C$. Within the
genesis, the semantics of the chain are defined by an initial state $\state_0$
known as the genesis state.

\subsection{State}

The state $s$ of any chain $C$ can be defined as a function $K \to V$ from
a key $k \in K$ to a value $v \in V$. We define the special form $s[k]$ which
can be described as
\[
    s[k] \equiv \begin{cases}
        v                   & \text{if} \quad k \in K \\
        \bot                & \text{otherwise}
    \end{cases}
\]
Amongst its elements, $s$ contains a function $s[\fold]$ or more succinctly
$\fold$ which describes how $s$ is interpreted.

\subsection{The $\fold$ Function} \label{fold-function}

The semantics of a chain $C$ are defined by a special function $\fold$ and an
execution context or environment $\env$. Formally, we can say
\[
    \fold \equiv (\env, t) \mapsto \env'
\]
where $\env$ is a given execution context, $t$ is an operation to be evaluated
within that context, and $\env'$ is the resulting context after applying
$\fold$.  In the context of our chain $C$, we can say that $\env \equiv \state$
and describe the state $\state_{h+1}$ of $C$ after applying a sequence of
transactions $t_1 \dots t_n$ as the recursive application:
\[
    \state_{h+1} \equiv \apply(\cdots \apply(\apply(\apply(\state_h,
    t_1), t_2), t_3) \cdots t_n).
\]

Since $\fold$ is defined within $\state$ as $\state[\fold]$, $\fold$ is also
able to amend itself as part of this state transition, and so we can say that
\emph{in some cases},
\[
    \fold(\state, t)[\fold] \neq \fold.
\]
Note that $t$ is not defined as part of the core architecture. Instead $t$ is
interpreted by the fold function $\fold$, and its semantics entirely determined
by it. This gives the high-level protocol implementation on top of the block-tree
complete flexibility.

\subsection{The Block-Tree}

So far we've talked about single chains with a state $\state$ and fold function
$\fold$, but our architecture notably allows chains to form a tree structure,
via a \emph{branching} operation. This ``block-tree'' is represented formally
as a set $\tree$ of chains, where every chain $C \in \tree$ is either the
parent of a chain, its descendant, or a sibling. When a chain $C'$ branches off
its parent chain $C$, we denote this as $C \prec C'$.

Though there is a clear hierarchy between the branches, blocks are allowed to
refer to an arbitrary number of parents, making the ``block-tree'' exhibit the
properties of a DAG.

% TODO: Is it just a DAG actually? If you just think of all parent pointers
% as equal, ie. even the ones pointing to the immediate chain, then it becomes
% a real DAG.

\subsection{Branching}

Besides the ability to change its chain state $\state$ as well as amend itself,
$\fold$ also has the ability to add a new chain $C$ to the set $\tree$, by
specifying its genesis $C_{gen}$. This is called \emph{branching}, and is
formally defined as
\[
    \mathsc{branch} \equiv \tree \mapsto \tree \cup \{\tuple{C_{id}, C_{gen}}\}.
\]
Thus, via $C_{gen}$, $\fold$ is able to specify new semantics that branch off
its parent chain.

\begin{verbatim}
  (branch "alice" `(set-fold! folds/account))
\end{verbatim}

The branch function is given a name $C_{id}$ for the new chain $C$ and an
optional list of operations to include in the genesis block $C_{gen}$. In this
case, $C_{gen}$ will contain one operation:

\begin{verbatim}
  `(set-fold! folds/account)
\end{verbatim}
which, when interpreted by $\fold_{gen}$, will evaluate \verb|(set-fold! folds/account)|
as an expression, which in turn will set the fold function for $C$ to the fold stored
under the \texttt{folds/account} key in $\state$.

\subsection{Homoiconicity}

\subsubsection{The Representation of $\fold$}

It should be obvious by now that $\fold$ has to be defined in such a way that
it may be part of $\state$. In other words, $\fold$ needs a representation
that is serializable over the network, and interpretable from its serialized
form. For this, we choose a subset of Scheme~\ref{scheme}.

Thanks to homoiconicity~\ref{homoiconicity}, block-trees can change their
behavior at runtime. Since the state $\state$ defines the fold function $\fold$
in $\state_{[\fold]}$, and the fold function can set any key in $\state$,
$\fold$ can modify itself based on some transaction input or code stored in
$\state$.

For instance, let's say a community wants to install a new rule, which only
allows transactions from users with a positive account balance. This particular
community has a repository under \texttt{acme/fold}} which defines its fold
function under \texttt{acme/fold/$\fold$}. By creating a proposal on
\texttt{acme/fold} which patches the fold function, the community can propose
change to its chain's behavior. Once the proposal is accepted, and the code is
merged, the patched fold function is picked up by the replicas and the behavior
of the chain is altered starting from the next block.

\subsection{Genesis}

The genesis $C_{gen}$ of any chain $C$ is special in that it is applied to the
state $C_{\state}$ by the genesis fold $\fold_{gen} : (\state, t) \to \state$.
This particular fold function is defined as
\[
    \fold_{gen}\;\equiv\;t \mapsto \eval t,
\]
where $\eval$ is the \emph{eval} function of our language. Thus, at genesis,
$t$ can be any valid scheme expression, \eg \verb|(+ 3 2)|, or in the case of a
repository chain, \verb|(set-fold! folds/repo)|.
