\section{Core Architecture}

% TODO: Reference Tezos.
% TODO: Reference Holochain.
% TODO: Reference Snowflake?
% TODO: Reference Scuttlebut.

In order to represent partial as well as totally ordered operations over the
network, \oscoin{} employs a DAG-like data-structure which we shall refer to as
the ``block-tree''.  Our block-tree starts from a \emph{root} chain and splits
into sub-chains via a process called branching. We thus refer to the sub-chains as
\emph{branches}.  Operations on the tree are represented by cryptographically
linked blocks of transactions (``blockchains''), with the most recent block in
any given branch known as the tip of the branch, or \emph{leaf}.

This design affords us several advantages over traditional blockchains, namely
the freedom to incorporate partially-ordered transactions within the semantics
of the protocol, as well as the ability to define semantics on a per-chain
basis, as we shall see in \S~\ref{fold-function}.

% TODO: Motivate the use of the fold. Basically, same thesis as Tezos, but
% done differently, with code on-chain. Also allows governance to change
% validation functions, which you can't do otherwise.
% Mimics the branching model of VCSs.

% * Partial ordering
% * Self-amending
%   * Governance (code on-chain)
%   * Protocol upgrade (semantics only)
% * Single writer
%   * Instant-finality
%   * Offline capable
%   * Agent-based
% * Scalability
%   * Logical sharding
%   * Selective syncing (following)

% TODO: Should we call the combination of state and fold the 'environment'?

\subsection{Overview}

The first block of any chain is called the \emph{genesis}. We represent chains
as a sequence of blocks $C \equiv B_0 \dots B_h$ where $B_0$ is the genesis,
$B_h$ is the leaf, and $h$ is the height of $C$. Within the genesis, the
semantics of the chain are defined by an initial state $S_0$ known as the
genesis state. The state of all chains is collectively known as the world state
$\state$ which represents a hierarchy of states starting from the root state
and descending into the state of each branch.

\subsection{State}

The state $S$ of a chain can be defined as a function mapping a key $k \in K$ to a
value $v$. We define the special form $S[k]$ as:
\[
    S[k] \equiv \begin{cases}
        v                   & \text{if} \quad k \in K \\
        \bot                & \text{otherwise}
    \end{cases}
\]

\subsection{The $\fold$ Function} \label{fold-function}

Within its codomain, $S$ contains a function $S[\fold]$ or more succinctly
$\fold$ which describes how $S$ is interpreted. This recursive definition
of $\fold$ is key.

The semantics of a chain $C$ are defined by a special function $\fold$ and an
execution context or environment $\env$. Formally, we can say
\[
    \fold \equiv (\env, t) \mapsto \env'
\]
where $\env$ is a given execution context, $t$ is an operation to be evaluated
within that context, and $\env'$ is the resulting context after applying
$\fold$.  In the context of our chain $C$, we can say that $\env \equiv \state$
and describe the state $\state_{h+1}$ of $C$ after applying a sequence of
transactions $t_1 \dots t_n$ as the recursive application:
\[
    \state_{h+1} \equiv \apply(\cdots \apply(\apply(\apply(\state_h,
    t_1), t_2), t_3) \cdots t_n).
\]

Since $\fold$ is defined within $\state$ as $\state[\fold]$, $\fold$ is also
able to amend itself as part of this state transition, and so we can say that
\emph{in some cases},
\[
    \fold(\state, t)[\fold] \neq \fold.
\]
Note that $t$ is not defined as part of the core architecture. Instead $t$ is
interpreted by the fold function $\fold$, and its semantics entirely determined
by it. This gives the high-level protocol implementation on top of the block-tree
complete flexibility.

\subsection{The Block-Tree}

So far we've talked about single chains with a state $S$ and fold function
$\fold$, but our architecture notably allows chains to form a tree structure,
via the \emph{branching} operation. This ``block-tree'' is represented formally
as a set $\tree$ of chains, where every chain $C \in \tree$ is either the
parent of a chain, its descendant, or a sibling. When a chain $C'$ branches off
its parent chain $C$, we denote this as $C \prec C'$.

Though there is a clear hierarchy between the branches, blocks are allowed to
refer to an arbitrary number of parents, making the ``block-tree'' exhibit the
properties of a DAG.

\subsubsection{The Root and Radicle}

In the beginning, we have only one chain, known as the \emph{root}, with a
single block, the \emph{radicle}. This initial state, which is effectively the
genesis of the first chain is the ancestor of all branches, and is the only
block with no parent.

Besides having no parent, the radicle is special in that it is applied to the
genesis state $\state_0$ by the genesis fold $\fold_{0}$. This particular fold
is defined as:
\[
    \fold_{0} \equiv (\env, t) \mapsto \eval (\env, t),
\]
or in other words,
\[
    \fold_0 \equiv \eval,
\]
where $\eval$ is the \emph{eval} function of some interpreted language $L$. Thus,
at genesis, $t$ can be any valid expression in $L$.

\subsubsection{Branching}

In every block header there is what we call a \emph{chain-id}. This identifier,
formally $H_{id}$ is used by the protocol to understand the intent of a block;
to decide what to do with it in the case where more than one block exists with
the same parent hash.

There are two scenarios at play, assuming only valid blocks.  Let $A$, $B$ and
$B'$ be blocks considered by the protocol where $A \prec B \wedge A \prec B'$.
Let $b$ be the chain-id of $B$,  $b'$ be the chain-id of $B'$,
$a$ be the chain-id of $A$, and $b \neq b'$.

\begin{enumerate}
    \item If $b = a$ and $b' = a$, then $B$ and $B'$ are in \emph{conflict}.
        This means only one of the two will be chosen to succeed $A$. To
        resolve this, the protocol uses the \textsc{score} function discussed
        in \S~\ref{consensus} to decide which block to build upon.
    \item If $b \neq a$ or $b' \neq a$, then we have a \emph{branch}. The block
        or blocks which do not have a matching chain-id with their parent $A$
        will consistute a new chain with new chain-id. This new chain will
        exist alongside $A$'s chain, and will share an ancestry or ``prefix''
        with $A$.
\end{enumerate}

% TODO: Diagram for this ^

