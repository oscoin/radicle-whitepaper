\section{Core Architecture}

In order to represent partial as well as totally ordered operations over the
network, \oscoin{} employs a treelike data-structure which we shall refer to as
the ``block-tree''.  Our block-tree starts from a \emph{root} chain and splits
into sub-chains we refer to as \emph{branches}.  Operations on the tree are
represented by cryptographically linked blocks of transactions
(``blockchains''), with the most recent block in any given branch known as the
tip of the branch, or \emph{leaf}.

This design affords us several advantages over traditional blockchains, namely
the freedom to incorporate partially-ordered transactions within the semantics
of the protocol, as well as the ability to define semantics on a per-chain
basis, as we shall see in \S~\ref{fold-function}.

% TODO: Should we call the combination of state and fold the 'environment'?

\subsection{Genesis}

The first block of any chain $C$ is called the \emph{genesis}. Within the
genesis, the semantics of the chain are defined by a fold function $\fold$ and
an initial state $\state_0$ known as the genesis state. Though $\fold$ is part
of $\state$, we shall sometimes refer to them separately for emphasis.  We can
thus describe the genesis block of a chain $C$, minimally as
\[
    C_{gen} \equiv \tuple{C_{\fold}, C_{\state_0}}.
\]

\subsection{The $\fold$ Function} \label{fold-function}

Describing the semantics of a chain $C$ is done via implementing $C_{\fold}$.
To understand why, we describe the state $\state_{h+1}$ of a chain after
applying a sequence of transactions $t_1 \dots t_n$ as the the recursive application of $\fold$ in
\[
    \state_{h+1} \equiv \apply(\cdots \apply(\apply(\apply(\state_h,
    t_1), t_2), t_3) \cdots t_n).
\]
Since $\fold$ is defined within $\state$, $\fold$ is also able to amend itself as
part of this state transition, and so we can say that
\[
    \fold(\state, t) \mapsto (\state', \fold').
\]
Note that $t$ is not defined as part of the core architecture. Instead $t$ is
interpreted by the fold function $\fold$, and its semantics entirely determined
by it, giving the high-level protocol implementation on top of the block-tree
complete flexibility.

\subsubsection{The Representation of $\fold$}

It should be obvious by now that $\fold$ has to be defined in such a way that
it may be part of $\state$. In other words, $\fold$ needs a representation
that is serializable over the network, and interpretable from its serialized
form. For this, we choose a subset of Scheme~\ref{scheme}.

\subsection{The Block-Tree}

So far we've talked about single chains with a state $\state$ and fold function
$\fold$, but our architecture notably allows chains to form a tree structure,
via a \emph{branching} operation. This ``block-tree'' is represented formally
as a set $\tree$ of chains, where every chain $C \in \tree$ is either the
parent of a chain, its descendant, or a sibling. When a chain $C'$ branches off
its parent chain $C$, we denote this as $C \prec C'$.

\subsection{Branching}

Besides the ability to change its chain state $\state$ as well as amend itself,
$\fold$ also has the ability to add a new chain $C$ to the set $\tree$, by
specifying its genesis $C_{gen}$. This is called \emph{branching}, and is
formally defined as
\[
    f : C_{gen} \to \tree \cup \{C\},
\]
where $C = (C_{gen})$. Thus, via $C_{gen}$, $\fold$ is able to specify new
semantics that branch off its parent chain.
