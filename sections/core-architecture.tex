\section{Core Architecture}

In order to represent partial as well as totally ordered operations over the
network, \oscoin{} employs a treelike data-structure which we shall refer to as
the ``block-tree''.  Our block-tree starts from a \emph{root} chain and splits
into sub-chains we refer to as \emph{branches}.  Operations on the tree are
represented by cryptographically linked blocks of transactions
(``blockchains''), with the most recent block in any given branch known as the
tip of the branch, or \emph{leaf}.

This design affords us several advantages over traditional blockchains, namely
the freedom to incorporate partially-ordered transactions within the semantics
of the protocol, as well as the ability to define semantics on a per-chain
basis, as we shall see in \S~\ref{fold-function}.

% TODO: Should we call the combination of state and fold the 'environment'?

\subsection{Genesis}

The first block of any chain $C$ is called the \emph{genesis}. Within the
genesis, the semantics of the chain are defined by a fold function $\fold$ and
an initial state $\state_0$ known as the genesis state. Though $\fold$ is part
of $\state$, we shall sometimes refer to them separately for emphasis.  We can
thus describe the genesis block of a chain $C$, minimally as
\[
    C_{gen} \equiv \tuple{C_{\fold}, C_{\state_0}}.
\]

\subsection{The $\fold$ Function} \label{fold-function}

Describing the semantics of a chain $C$ is done via implementing $C_{\fold}$.
To understand why, we describe the state $\state_{h+1}$ of a chain after
applying a sequence of transactions $t_1 \dots t_n$ as the the recursive application of $\fold$ in
\[
    \state_{h+1} \equiv \apply(\cdots \apply(\apply(\apply(\state_h,
    t_1), t_2), t_3) \cdots t_n).
\]
Since $\fold$ is defined within $\state$, $\fold$ is also able to amend itself as
part of this state transition, and so we can say that
\[
    \fold(\state, t) \mapsto (\state', \fold').
\]
Note that $t$ is not defined as part of the core architecture. Instead $t$ is
interpreted by the fold function $\fold$, and its semantics entirely determined
by it, giving the high-level protocol implementation on top of the block-tree
complete flexibility.

\subsubsection{The Representation of $\fold$}

It should be obvious by now that $\fold$ has to be defined in such a way that
it may be part of $\state$. In other words, $\fold$ needs a representation
that is serializable over the network, and interpretable from its serialized
form. For this, we choose a subset of Scheme~\ref{scheme}.

\subsection{The Block-Tree}

So far we've talked about single chains with a state $\state$ and fold function
$\fold$, but our architecture notably allows chains to form a tree structure,
via a \emph{branching} operation. This ``block-tree'' is represented formally
as a set $\tree$ of chains, where every chain $C \in \tree$ is either the
parent of a chain, its descendant, or a sibling. When a chain $C'$ branches off
its parent chain $C$, we denote this as $C \prec C'$.

\subsection{Branching}

Besides the ability to change its chain state $\state$ as well as amend itself,
$\fold$ also has the ability to add a new chain $C$ to the set $\tree$, by
specifying its genesis $C_{gen}$. This is called \emph{branching}, and is
formally defined as
\[
    \mathsc{branch} \equiv \tree \mapsto \tree \cup \{\tuple{C_{id}, C_{gen}}\}.
\]
Thus, via $C_{gen}$, $\fold$ is able to specify new semantics that branch off
its parent chain.

\begin{verbatim}
  (branch "alice" `(set-fold! folds/account))
\end{verbatim}

The branch function is given a name $C_{id}$ for the new chain $C$ and an
optional list of operations to include in the genesis block $C_{gen}$. In this
case, $C_{gen}$ will contain one operation:

\begin{verbatim}
  `(set-fold! folds/account)
\end{verbatim}
which, when interpreted by $\fold_{gen}$, will evaluate \verb|(set-fold! folds/account)|
as an expression, which in turn will set the fold function for $C$ to the fold stored
under the \texttt{folds/account} key in $\state$.

\subsection{Homoiconicity}

Thanks to homoiconicity~\ref{homoiconicity}, block-trees can change their
behavior at runtime. Since the state $\state$ defines the fold function $\fold$
in $\state_{[\fold]}$, and the fold function can set any key in $\state$,
$\fold$ can modify itself based on some transaction input or code stored in
$\state$.

For instance, let's say a community wants to install a new rule, which only
allows transactions from users with a positive account balance. This particular
community has a repository under \texttt{acme/fold}} which defines its fold
function under \texttt{acme/fold/$\fold$}. By creating a proposal on
\texttt{acme/fold} which patches the fold function, the community can propose
change to its chain's behavior. Once the proposal is accepted, and the code is
merged, the patched fold function is picked up by the replicas and the behavior
of the chain is altered starting from the next block.

\subsection{Genesis}

The genesis $C_{gen}$ of any chain $C$ is special in that it is applied to the
state $C_{\state}$ by the genesis fold $\fold_{gen} : (\state, t) \to \state$.
This particular fold function is defined as
\[
    \fold_{gen}\;\equiv\;t \mapsto \eval t,
\]
where $\eval$ is the \emph{eval} function of our language. Thus, at genesis,
$t$ can be any valid scheme expression, \eg \code{(+ 3 2)}, or in the case of a
repository chain, \code{(set-fold!~folds/repo)}.
