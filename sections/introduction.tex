\section{Introduction}
\label{s:introduction}

Blockchains are being used with increasing frequency, and for increasingly
diverse purposes. This had led to scaling concerns, as clients must keep
abreast of a large number of transactions, many of which are will not be
directly relevant to them. There are several protocol-level efforts to assuage
these concerns. The \oscoin{} architecture, however, emphasizes an additional,
\textit{semantic} level of separation. Rather than a single chain, \oscoin{}
allows for an indefinite number of different chains, each serving different
purposes -- such as keeping track of a particular repository, of the outcome of
a vote, or of global financial transactions. In general, participants need not
sync chains which are not of interest to them, saving considerable space,
computation, and network usage.

Since the purpose of chains may thus be quite specific, we would like to be
able to precisely specify what sorts of transactions are allowed on it, and to
optimize syntax and semantics for those use-cases. In essence, we want
\textit{domain-specific languages for domain-specific chains}. The language
described in this paper, \rad, is designed to easily allow the definition of
such domain-specific languages (DSLs). Moreover, the very same mechanism used to
facilitate such definitions - a \textit{reflective tower} - also
allows for redefining the semantics of a single chain, enabling a more
principled and first-class version of the self-amendment pioneered by
Tezos.\cite{Goodman2014} The existence of a single language in which such DSLs
are defined \textit{on-chain} also ensures that there is no need for
out-of-band communication, making it trivial to agree upon the semantics of
these DSLs.

In addition to being a language for on-chain programming, \rad is also a
scripting language that can be used to script local interactions with the
chain. Indeed, chains, scripts, and REPL interactions are conceived of
uniformly. This in turn allows quite novel possibilities; one can for
example describe on one chain how a server should respond to updates of another
chain, so that redeployments to that server become as simple as submitting new
transactions to the server-chain.

\subsection{Context}

Satoshi Nakamoto's Bitcoin introduced a practical digital currency with no
centralized backing.\cite{Nakamoto2008} This was enabled by a system for
distributed consensus known as a blockchain. In essence, a blockchain is a
distributed log of \textit{transactions}. Transactions are grouped into
\textit{blocks}, which in addition to the ordered list of transactions
contain an identifiers for their parent block (as well as other metadata). Each
client maintains a set of blocks it knows about, which need not form a chain
(i.e., there may be multiple blocks with the same parent, constituting a
\textit{fork}). A \textit{scoring function} is used to select the best chain.
The nature of this scoring function is such as to ensure that, with a high
degree of probability, participants will converge on the same chain, even in
the presence of (some amount of) network latency, network partitions, and
malicious behaviour.

Already with Bitcoin Script--the stack-based language
defined by Bitcoin's protocol for describing ownership rights to a
Bitcoin--programming languages were seen to be the means of establishing what
consensus was \textit{about}; not, that is, just a semantically opaque list of
strings which consistute the log or ledger, but as a list of string that
determined in an agreed-upon way a semantically significant \textit{state}.
Since mostly blockchain technology has been used as a digital currency, this
state usually represents the ownership of designated coins, or in an
alternative formulation, the balances of individual accounts.

% As part of the consensus process, \textit{validators} evaluate the transactions
% (subprograms of the relevant programming language) in order to calculate the
% resulting state and determine if both the transactions, and the \textit{blocks}
% into which they are organized, are valid.\footnote{There is no fundamental
% reason that evaluation and validation need be so intertwined. In theory,
% validation could be simply succesful typechecking of a total language, for
% example; evaluation would then be an extra step not influencing validity.
% However, it is hard to see what the benefits of such a system would be.} Blocks
% relate to one another by explicitly declaring their predecessor, thus
% constituting a \textit{chain}; if
% multiple valid blocks exist with the same predecessor or parent (this constitutes a
% \textit{fork}), clients such as validators adopt by convention a rule for
% determining which set of blocks to consider canonical. These rules are designed
% to ensure that, with a high degree of probability, clients will converge on the
% same chain. Seen from another perspective, clients will
% converge on what \textit{program} they run.

% TODO: The ordering of these paragraphs isn't great.

Later cryptocurrencies such as Ethereum emphasized more powerful programming
languages. This in turn made clear that distributed consensus about program
source had applications that were much broader than simple exchanges. Still,
such applications were built on top of a model that focused on accounts,
balances, and transactions, limiting the ease with which such alternative
applications could be developed.



\subsection{\rad: Motivation and Desiderata}

A natural extension of this trend is to free blockchain programming from the
notion of ownership completely, and see it for what it is: a distributed and
interactive program.

Even if we make no assumption about the application of such a program (such as
ownership and transaction), certain considerations about the nature of
blockchain programming are important for the design of a general-purpose
blockchain language.

\begin{description}
  \item [Purity] First, in order for consensus to be achievable, there must be
      agreement among participants on the meaning and validity of blocks and
        transactions. Seen from the perspective of programming languages, the
        meaning of an expression or declaration must be the same for all users.
        This leads naturally to a \textit{pure} programming language - one
        which side-effects are disallowed.

  \item [Constrainability] Since anyone may submit an expression or transaction
      to the chain, and all validators evaluate it, both Bitcoin and Ethereum
        have mechanisms to prevent expressions requiring too much (even
        infinite) computation, which would represent a denial-of-service like
        attack on validators. This avoid limiting or \textit{constraining} the
        language.

\end{description}


\begin{figure}[H]
\begin{tabular}{| l | l | l |}
\hline
Version Control & Blockchain     & Language  \\ \hline
    Patch/Diff  & Transaction    & Declaration\footnote{\rad makes no
    distinctions between declarations and expressions, and so for the purposes
    of this paper one may consider this cell to be filled with ``Expression''}\\
Branch/Fork     & Fork           & ...  \\
Snapshot        & State          & Memory + Env \\
\hline
\end{tabular}
\label{correspondences}
\caption{Correspondences ...}
\end{figure}
