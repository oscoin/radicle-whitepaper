\section{Network Protocol and Architecture}

The \oscoin{} network protocol is a realization of the protocol semantics
described in \S~\ref{sec:protocol-semantics}, into the asynchronous network
model.

\subsection{Overview}

The \oscoin{} network is composed of a set of nodes, or \emph{replicas}, which
execute a protocol $\mathcal{P}$. Together, these nodes form a \emph{Replicated
State Machine} with a set of states $\State^*$, a transition function $\apply$,
a starting state $\State_0$, a set of inputs $B_0 \dotso B_n$, and an empty set
of outputs.

% TODO: Are we using the 'P' variable?

Participation in the network protocol is \emph{open} (\ie ``permissionless''),
which makes the replica set dynamic. To achieve consensus in the permissionless
setting, we make use of \emph{blockchains}~\cite{bitcoin} as the underlying
replicated data-structure, with the assumption that a greater than $50\%$
majority of replicas are honest.  However, unlike other blockchain protocols,
we describe a ``block-lattice'' design (Figure~\ref{block-lattice}.) in the
spirit of \cite{raiblocks}, with causal consistency guarantees
\cite{causal-consistency} and partial ordering across chains.

\subsubsection{Block-lattice Architecture}

\begin{figure}[hbp]
    \input{figures/block-lattice.tikz}
    \caption{Block-lattice design. $B_a$, $B_b$ and $B_c$ are chains partially ordered in relation to one another.\label{block-lattice}}
\end{figure}

Block-lattices are a replicated data-structure composed of chains of blocks,
depicted in Figure~\ref{block-lattice}.  Both parallel and synchronized
operations are able to be expressed with this design:  a pair of transactions
on two chains are considered \emph{free}, if they may be processed in parallel,
or \emph{dependent}, if a causal or acausal dependency exists between them.

Each chain in our design functions as a logical unit of organization,
governance, and funding. In other words, each user, organization or community
is expected to operate under their own chain. These individual chains are
called \emph{accounts}. The block-lattice design has numerous advantages for
our use case, including parallel transaction processing, logical sharding and
the ability to trivially fork individual communities or organizations.

\subsection{Threat Model}

We assume a majority ($> 50\%$) of honest, or \emph{compliant} nodes which follow
the protocol. In other words, for $f$ non-compliant (faulty) nodes, we assume a
network of $2f+1$ nodes in total.

\subsection{Blocks, State and Transactions}

In \S~\ref{operations-and-state}, we saw that the protocol semantics could
be defined in terms of a global state $\State$ and a sequence of operations
$\op_1 \dotso \op_n$ applied to $\State$, forming a ledger $\Ledger$. When
describing the network architecture and protocol, a direct mapping between
these abstract objects and the components of the software architecture exist.

\subsubsection{State}

The state $\State$ is represented by a function $\State : K \to V$ which maps a
set of keys $K \in \mathbb{B}^{256}$ to a set of values $V \in \mathbb{B}^{*}$,
where $\mathbb{B}$ is the set of bytes, and $\mathbb{B}^n$ is the set of byte
strings of length $n$. The initial state $\State_0$ is called the
\emph{genesis} state. Since we are working with multiple chains, and each
chain represents an account's ledger, we define $\mathcal{A}_i$ to be the state
of account $i$ and $\mathcal{L}_i$ to be $i$'s ledger.

\subsubsection{Block}

An operation $\op$ is represented by a sequence of one or more transactions,
organized in a \emph{block}. A ledger $\Ledger$ of all valid recorded
operations is represented as a sequence of blocks, or \emph{blockchain}. A
block $B$ in \oscoin{} consists of a block header $B_H$ with a set of fields
(Table~\ref{block-header-fields}.) and a sequence of transactions $B_T = (t_0
\dotso t_n)$.

% TODO: Is it zero or more txns?

\begin{table}[hbtp]
    \caption{Block header fields \label{block-header-fields}}
    \begin{tabular}{l c p{7.5cm}}
        \toprule
        Field                  & Notation & Description \\
        \midrule
        \emph{Chain}           & $H_{id}$ & The name or identifier of the chain, \eg ``oscoin.'' \\
        \emph{Height}          & $H_n$    & The block height. \\
        \emph{ParentHash}      & $H_p$    & The \hash{} hash of the parent block header. \\
        \emph{TransactionRoot} & $H_{tr}$ & The root of the transaction hash tree. \\
        \emph{StateRoot}       & $H_{sr}$ & The \hash{} hash of the root of the state
                                            tree after all transactions in the block have
                                            been applied. \\
        \emph{Author}          & $H_a$    & The author of the block, and address to which
                                            all transaction fees collected in this block
                                            should be sent. \\
        \emph{Timestamp}       & $H_t$    & The local time of the author of this block at
                                            the time of authorship. \\
        \emph{ConsensusHash}   & $H_c$    & The \hash{} hash of the consensus parameters
                                            with which to validate the next block. \\
        \bottomrule
    \end{tabular}
\end{table}

% TODO: Sender account has a nonce.

\subsubsection{``Free'' Transactions}

Transactions which can be validated and applied to the state $\State$
individually are called \emph{free}. Free transactions can always be processed
in parallel because the resulting state after applying a free transaction does
not need to be observed by other chains. Formally, if $t$ is a free transaction
on chain $a$, the resulting state $\State'[a] \equiv \apply(\State[a], t)$
is not observable by any chain $c$ where $c \neq a$.

With the exception of \textsc{open}, all transactions carry an implicit account
context $a$, to which they are applied.

\begin{description}
    \item[Open] $\tx{open}{a_{pk}, a_{gen}, a_{addr}}_{\sigma}$.  Open a new
        account. This is the first transaction any organization or user must
        submit to initialize their account and chain.  $a_{pk}$ is the public
        key of the user registering the account, $a_{gen}$ is the genesis state
        of the account, and $a_{addr}$ is its public address.  Once processed,
        this transaction functions as the ``genesis block'' of an account.
    \item[Fork] $\tx{fork}{k_c, k_{c'}}_\sigma \; \text{where} \; k_c =
        \mathcal{C}_{\varnothing}$. Create a new context $k_{c'}$ by forking
        the empty context $\mathcal{C}_{\varnothing}$. This transaction can
        be used to create new code repositories.
    \item[Issue] $\tx{issue}{i_{id}, i_{c}}_\sigma$. Open an issue. The $i_{id}$
        parameter is used to reference the issue in subsequent transactions,
        while $i_c$ is the context in which to create the issue.
    \item[Amend] $\tx{amend}{i_{id}, i_{s}, i_{b}, i_P}_\sigma$.
        Update an issue's subject, body or patchset.
    \item[Voice] $\tx{voice}{i_{id}, v}_\sigma$.  Adds a voice $v$ to the issue
        $i$, where $v \in \{accept, reject\}$.
    \item[Bond] $\tx{bond}{b_{s}, b_{r}, b_{v}}_{\sigma}$. Bond $b_v$ tokens
        from the source address $b_{s}$ to the bonding address $b_r$. The
        signature $\sigma$ is used to unlock $b_s$.
    \item[Unbond] $\tx{unbond}{b_{s}, b_{r}, b_{v}}_{\sigma}$. Start unbonding
        $b_v$ tokens from the bonding address $b_{s}$ and credit $b_r$ when
        the unbonding period is over. The signature $\sigma$ unlocks the
        bonded tokens in $b_s$.
    \item[Set] $\tx{set}{s_k, s_v}$. Set an arbitrary key $s_k$ to the value
        $s_v$.
\end{description}

\subsubsection{``Dependent'' Transactions}

Transactions which appear in pairs accross two accounts are called
\emph{dependent} (Figure~\ref{tx-dependencies}.), due to only being valid when
applied in pairs. Typically, these transactions affect both accounts and
require temporary synchronization for both transactions to be observed and
processed by a node.

\begin{figure}[hbp]
    \input{figures/tx-dependencies.tikz}
    \caption{Three accounts, $A$, $B$ and $C$, and their transaction chains.
        The diagram illustrates free transactions, such as \textsc{open} and
        \textsc{patch}, as well as dependent transactions such as \textsc{send}
        and \textsc{receive}.  The dashed lines represent cross-chain
        synchronizations between dependent transactions.
    \label{tx-dependencies}}
\end{figure}

\begin{table}[hbtp]
    \begin{tabular}{l c p{7.5cm}}
        \toprule
        Field                  & Notation & Description \\
        \midrule
        \emph{Chain}           & $H_c$    & The name or identifier of the chain, \eg ``oscoin.'' \\
        \emph{Height}          & $H_n$    & The block height. \\
        \emph{ParentHash}      & $H_p$    & The \hash{} hash of the parent block header. \\
        \emph{TransactionRoot} & $H_{tr}$ & The root of the transaction hash tree. \\
        \emph{StateRoot}       & $H_{sr}$ & The \hash{} hash of the root of the state
                                            tree after all transactions in the block have
                                            been applied. \\
        \emph{Author}          & $H_a$    & The author of the block, and address to which
                                            all transaction fees collected in this block
                                            should be sent. \\
        \emph{Timestamp}       & $H_t$    & The local time of the author of this block at
                                            the time of authorship. \\
        \emph{ConsensusHash}   & $H_c$    & The \hash{} hash of the consensus parameters
                                            with which to validate the next block. \\
        \bottomrule
    \end{tabular}
    \medskip
    \caption{Block header fields \label{block-header-fields}}
\end{table}
