\section{Formal Semantics}

The rules according to which transactions on the \oscoin{} network are
validated comprise a \emph{protocol}. This protocol has a well defined semantics
which we shall describe in this section.

\subsection{Operations}

Operations are signed messages constructed by participants in the protocol,
which trigger a state transition in the network. A valid operation $T$ takes
the form:
\[
    T \equiv \langle T_i, T_m, T_p, T_n \rangle_{\sigma}
\]
where $T_i$ is the identity of the sender of the operation, $T_m$ is the
message, $T_p$ is a reference to a parent operation which $T$ should succeed,
and $T_n \in \mathbb{N}$ taken together with $T_i$ forms a globally unique
operation identifier, such that there can be at most one operation with a
certain $\langle T_i, T_n \rangle$ tuple.

A valid operation $T$ applied to the current state of
the protocol $\mathcal{S}_e$ at epoch $e$ can be formulated as:
\[
    \mathcal{S}_{e+1} \equiv \delta(\mathcal{S}_e, T)
\]
where $\delta$ is \emph{apply}, the state-transition function.  We can
describe the current state of the network $\mathcal{S}_e$ as a sequence of
operations ${T_1 \dots T_e}$ applied recursively to an initial empty state
$\varnothing$:
\[
    \mathcal{S}_e \equiv \delta(\dots \delta(\delta(\delta(\varnothing,
    T_1), T_2), T_3), \dots T_e)
\]

\subsection{Code} The fundamental product or \emph{artifact} of the \oscoin{}
network is code, or source code. Our protocol defines the \emph{patch}
primitive as the atomic unit of code. A patch is a set of metadata and code
changes, or \emph{changeset}, that can be applied to an existing body of code,
or \emph{context}, to modify it. We define a patch $P$ as the tuple $\langle
P_a, P_m, P_f \rangle$, where $P_a$ is the author of the patch, $P_m$ is the
patch metadata and $P_f$ is the changeset. A set of patches in no particular
order is called a \emph{patchset}.

Patches can be composed sequentially, taking an initial context $A$ into
a modified context $B$. The empty context is defined as $\varnothing$, such
that there exists a mapping $P_f \varnothing \mapsto P_f$. Let $f \prec g
\prec h$ be an ordered sequence of patches, then the formulation:
\[
h \cdot g \cdot f : A \to B
\]
is the in-order composition of patches $f$, $g$ and $h$, taking an initial
context from $A$ to $B$.

% TODO: Contexts form a free monoid?
% TODO: Reference patch theory.

\subsection{Issues}

On the \oscoin{} network, collaboration on code takes place through \emph{issues};
and since project governance is specified in code---through the use of
\emph{smart contracts}---organizational decisions are also made through issues.

An issue $I$ is described at epoch $e$ by the tuple:
\[
    \big<\langle I_a, I_t, I_b, I_o, I_r, I_P \rangle_{\sigma}, I_s, I_V \big>_e
\]
where $I_a$ is the issue author, $I_t$ is the title or subject of the issue,
$I_b$ is the description in plain text of the issue, $I_o$ is a list of
operations to be applied when $I_s$ changes, $I_r$ is the issue resolution
function, $I_P$ is the patchset attached to the issue, $\sigma$ is the
signature of $I_a$, $I_s \in \{open, closed, accepted, rejected\}$ is the
current state of the issue and $I_V$ is the set of votes on the issue. The
initial value of $I_s$, $I_{s_0} = open$, the initial value of $I_V$, $I_{V_0}
= \varnothing$ and the initial value of $I_P$, $I_{P_0} = \varnothing$.  A list
of valid state transitions between any two states $I_s$ and $I_{s'}$ can be
found in Table \ref{issues-valid-transitions}.

\begin{table}[hbt]
    \caption{\label{issues-valid-transitions}}
    \begin{tabular}{rcl}
        \toprule
        $I_s$      & $\to$ & $I_{s'}$ \\
        \midrule
        $open$     & $\to$ & $accepted$ \\
        $open$     & $\to$ & $rejected$ \\
        $open$     & $\to$ & $closed$ \\
        $closed$   & $\to$ & $open$ \\
        \bottomrule
    \end{tabular}
\end{table}

The patchset $I_P$ attached to an issue represents a set of proposed changes to
some project, while the subject $I_t$ and body $I_b$ of the issue provide a
description of the changes contained in $I_P$. Issue \emph{resolution} is the
process of voting on an issue with the aim to move to an \emph{accepted} or
\emph{rejected} state.

Issues can be voted on with the \emph{voice} operation. When an issue receives
a new vote, it is added to $I_V$. A vote $v$ is represented by the tuple
$\langle v_i, v_a, v_{\omega}, v_e \rangle_{\sigma}$ where $v_a$ is the voter,
$v_i$ is the issue being voted on, $v_{\omega} \in \{accept, reject\}$ and
$v_e$ is the epoch $e$ at which the vote is valid.

When a certain threshold of votes is reached, an issue transitions to either an
\emph{accepted} or \emph{rejected} state. Given an open issue $i$, the rules of
issue resolution are defined by the function $i_r : I \to I$, applied to the
issue $i$ for every vote added to $i_V$.

\subsubsection{Amendments}

An issue $I$ where $I_s = open$ can be amended with the \emph{amend} operation
$\amend$. Only $I_t$, $I_b$, $I_o$, $I_r$ and $I_P$ can be amended.  Amending an issue creates
a new empty set of votes $V'$, ensuring two versions of a given issue never
share a set of votes. Formally, amendment is defined as:
\begin{align*}
    I \amend{} \langle I_a, t', b', o', r', P' \rangle_{\sigma} \equiv
    \big<\langle I_a, t', b', o', r', P' \rangle_{\sigma}, I_s, \varnothing
    \big>, \qquad I_s = open
\end{align*}

% TODO: The amendment should include the issue it is amending.

\subsubsection{Accepted Issues} When an issue has been accepted by a majority
of votes, the issue transitions permanently into an \emph{accepted} state. The
steps taken by the protocol are as follows:

\begin{enumerate}
    \item The issue's state $I_s$ is set to \emph{accepted}.
    \item The issue is \emph{frozen}, such that no further amendments or state
        changes are possible.
    \item The list of operations $I_o$ belonging to the issue are executed by
        the protocol.
    \item The issue's \emph{patchset} $I_P$ is permanently added to the code
        project it pertains to. Note that a patchset may contain individual
        patches pertaining to different projects, in which case the patches are
        applied individually to their respective projects.
\end{enumerate}

\subsubsection{Rejected issues} When an issue is rejected,
\begin{enumerate}
    \item The issue transitions to a \emph{rejected} state.
    \item The issue is frozen so that no further amendments or state
        transitions are possible.
    \item The list of operations $I_o$ belonging to the issue are executed by
        the protocol.
\end{enumerate}

\subsubsection{Closed issues} When an issue is closed, its state changes to
\emph{closed} until it is re-opened. No operations from $I_o$ are run, since
an issue can be opened and closed many times. Only the author $I_a$ of an issue
can close it.
