\section{Language Syntax and Semantics}
\label{s:language}

\rad is a a Lisp dialect. It uses prefix parenthesized function application,
supports recursion, has first-class functions, is dynamically typed, and
homoiconic. It differs from most Lisps in a few aspects, described below.

Like most Lisps, binding is lexical. Unlike most Lisps, \rad has a
\textit{hyperstatic} global environment, meaning that the resolution of free
variables takes place at the definition site rather than call-site. Thus:

\begin{verbatim}
(define foo x) ;; error - "x" is not defined
(define x 3)
(define foo x)
(foo) ;; 3
(define x 5)
(foo) ;; still 3
\end{verbatim}

Programs can be viewed as the ledger of inputs to the replicate state machine.
Thus, \rad programs are usually an interleaving of code written by multiple
people, and each developer cannot in general be certain of what code will end
up in the program between the text that she knows about and her new submission.
A hyperstatic environment ameliorates the resulting unpredictability by making
function calls by default (i.e., modulo the usage of mutable references)
independent of intermediate submissions.

\rad does not have macros. Instead, it allows for a complete redefinition of
the intepreter via redefinitions of \texttt{eval}.

\begin{verbatim}
(define eval (lambda (expr) 3)) ;;
5 ;; --> 3
\end{verbatim}

This enables users to very easily define sublanguages for new chains, or amend
the language running in the current one. A simplistic key-value store may thus
be defined in only a few lines of code:

\begin{lstlisting}
(define store (ref dict))

(define eval (lambda (expr)
  (define s (read-ref store))
  (if (eq? (head expr) 'get)
      (lookup (head (tail expr)) s)
      (if (eq? (head expr) 'set)
          (modify-map
            (head (tail expr))
            (lambda (st)
                    (head (tail (tail expr))))
            store)
          'invalid-command))))

\end{lstlisting}

After which we have:

\begin{verbatim}
(set key1 3) ;; => ()
(get key1) ;; => 3
(+ 3 2) ;; => 'invalid-command

;; Nested expressions are not evaluated:
(set key2 (+ 3 2)) ;; => ()
(get key2) ;; => '(+ 3 2)
\end{verbatim}

% TODO: maybe move to Related Work section
\subsection{Connection to Reflective Towers} The \texttt{eval}-redefinition
mechanism resembles prior work on \textit{reflective towers}. A reflective
tower is an infinite series of levels of interpreters, $L_0$, $L_1$, ..., where
a level $L_n$ is interpreted by $L_{n+1}$. Reflective towers allow both
\textit{reification} - the ability to inspect a computation via constructs of a
higher level - and \textit{reflection} - the ability to define and enter new,
lower levels. Conceptually, \rad differs from reflective towers by only
allowing reflection. Thus, the only levels that exist are the ones programs
create. Queinnec has quipped that reflective languages ``plunge us into a world
with few laws, and hardly any gravity''\cite{Queinnec1994}; the more disciplined approach to
reflection that \rad takes does not possess the semantic fragility as modifying
meta-meta-intepreters.

The techniques that have been developed for reducing the interpretive overhead
of such towers of interpreters, however, still
apply (see, for example, \cite{Amin2017}, \cite{Asai2014}), as do simpler
partial-evaluation-based approaches such as \cite{Brown2017}.



\subsection{Effects} In order to maintain determinism and safety in on-chain
computations, and at the same time be a useful language for scripting
interactions with chains, \rad keeps a separate, \textit{impure} environment,
$\rho_{!}$ (these are by convention textually distinguished by identifiers
ending with an exclamation mark). Expressions on chain therefore cannot have
side-effects; instead, they may evaluate to a value that \textit{describes} an effect,
but the decision of whether or how to actually carry on that effect happens at
effect-handling layer. This architecture, with a central authority
administering effects received via messages, resembles work following
\cite{Cartwright1994} and \cite{Bauer2003}.


\begin{figure}[H]
\begin{tikzpicture}[node distance = 4cm, auto]
  \node [block] (net) {Network};
  \node [block, below of=net] (repl) {REPL};
  \node [block, left of=repl] (impure) {effect handler};
  \node [block, below of=impure] (pure) {pure evaluation};
  \node [block, above of=impure] (file) {File};

    \path [line]
    (file) -- node [left] {\texttt{read-line!} $V_{n+1}$} (impure);

    \path [line, transform canvas={yshift=0.2cm}]
    (net) -- node {\texttt{gossip!} [$B_n$]} (impure);
    \path [line, transform canvas={yshift=-0.2cm}]
    (impure) -- node {\texttt{hear-gossip!} $V_{n+1}$} (net);

    \path [line, transform canvas={yshift=0.2cm}]
    (repl) -- node [above] {\texttt{get-line!} [$B_n$]} (impure);
    \path [line, transform canvas={yshift=-0.2cm}]
    (impure) -- node [below] {\texttt{print!} $V_{n+1}$} (repl);

  \path [line, transform canvas={xshift=0.2cm}]
    (impure) -- node {$S_n$, $B_n$} (pure);
  \path [line, transform canvas={xshift=-0.2cm}]
    (pure) -- node {$S_{n+1}$, $V_{n+1}$} (impure);

\end{tikzpicture}
\caption{Effect system}
\label{f:effects}
\end{figure}

The value that results from evaluating an expression purely may, in addition to
\textit{describing} an effect, pass a continuation with the result of that
effect (if any). The effect-handling layer can chose to only call continuations
without arguments. This in turn means the continuation will not have access to
the result of effectful computations, though it may (at the discretion of the
effect-handling layers) have output effects.

\begin{figure}[H]
\begin{lstlisting}
(define repl
  (sorted-map
    name "repl"
    getter (quote (get-line!))))

(subscribe-to! repl
  (lambda (x)
    (print! (default-impure-handler! x))))
\end{lstlisting}
    \caption{A simple effect handler. The function \texttt{subscribe-to!}
    repeatedly calls the \texttt{getter} key of its first argument, handling
    effects with its second argument. \texttt{default-impure-handler!} handles
    effects by calling the impure function corresponding to the effect tag. If
    we remove it, keeping only \texttt{(print! x)}, we would see printed in the
    console the value that describes an effect only.}
\label{f:eff-handler}
\end{figure}

A further advantage of this approach is that, since on many blockchain
protocols new blocks have a low initial probability of being final (given the
possibility of forks), effects may be easily and programmatically delayed until
sufficiently many child blocks have been seen by simply buffering the
description of effects before passing them to the effect-handling layer.

\subsection{Data types} \rad's data types are: booleans (\texttt{\#t} and
\texttt{\#f}); strings (a sequence of characters within double quotes, with
\texttt{\textbackslash} as the escape character), symbols, lists, dictionaries
(maps), and numbers (currently only arbitrary-precision decimals). These
datatypes are all immutable; additionally \rad supports \textit{refs}--mutable
references--that can hold any other datatype.

\subsection{Syntax}


\subsection{Formal Semantics} We define the denotational semantics of \rad
recursively. The base case, $\mathcal{E}_{0}$, describes the denotation of a
term prior to any modification of \texttt{eval}. It's definition is given in
Figure \ref{f:denotationalsem0}.

\begin{figure}[H]
\begin{align*}
    Environment [\env] &= Identifier \rightarrow Value \\
    Memory [\mem] &= Value \rightarrow Value \\
    Value [\val] &= Address + Function + Boolean ... \\
    Continuation [\cont] &= Value \times Memory \rightarrow Value \\
    Function [\phi] &= Value* \times Continuation \times Memory \rightarrow Value
\end{align*}
\label{f:denotationalsemleged}
\end{figure}

\begin{figure}[H]
\begin{align*}
    \denotationdesc{0}{\variable}{(\cont (\env \variable) \mem)} \\
  \denotationdesc{0}{(\lam (\variable *) \rho^{+})}{} \\
    \denotationdesc{0}{(\define \variable \pi )}{} \\
    \denotationdesc{0}{(\deref \variable  )}{\cont (\mem (\texttt{toAddress}(\env \variable)))) \mem} \\
  \denotationdesc{0}{(\mkref \variable \pi)}{} \\
  \denotationdesc{0}{(\set \variable \pi)}{} \\
  \denotationdesc{0}{(\ifm \pi_0 \pi_1 \pi_2)}{\denotation{0}{\pi_0}\env
    \lambda \val \mem_1 .(\text{if } \val  \\
    \text{then } \denotation{0}{\pi_1}  \\
    \text{else } \denotation{0}{\pi_2} \\
    \text{endif } \env \cont \mem_1)  \mem ) }
\end{align*}
\caption{Denotational semantics for $\mathcal{E}_{0}$}
\label{f:denotationalsem0}
\end{figure}

After a redefinition of \texttt{eval}, the denotation of an expression is the
denotation of \texttt{eval} prior to the redefinition, applied to the
\textit{quoted} expression, as show in Figure \ref{f:denotationalsemn}.

\begin{figure}[H]
\begin{align*}
  \denotationdesc{n}{\pi}{(\denotation{n-1}{\evalm} (\quotem \pi))\env\cont\mem}
\end{align*}
\caption{Denotational semantics for $\mathcal{E}_{n}$}
\label{f:denotationalsemn}
\end{figure}

Besides the forms described so far, additional forms exist which may be
implemented via \texttt{eval} redefinitions. They may also be implemented as
primitives; in either case, these forms must not be shadowable via
\texttt{define}s.
