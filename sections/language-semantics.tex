\section{Language Syntax and Semantics}
\label{s:language}

Technologically speaking, \rad doesn't bring anything new to programming
language design. It is essentially a specific point in the design-space (and
related tooling) optimized for the following goals:
\begin{itemize}
\item[(1)] To be deterministic, so that \rad programs specifiy deterministic
  state machines.
\item[(2)] To be powerful enough to be a `universal state-machine'.
\item[(3)] To be able to restrict this power appropirately, so that malicious
  inputs can be rejected.
\item[(4)] To be concise, expressive and emphesize correctness, so that new
  chains, with new semantics can be created cheaply (in terms of development
  time), be easily understood by all participants, and hopefully be bug-free.
\item[(5')] To work well in a collaborative setting, which code being submitted
  by multiple parties in a potentially unspecified order.
\item[(5)] To have as simple as possible underlying underlying semantics, so
  that \rad interpreters are well specified, and so that \rad can be used in
  security sensitive situations.
\item[(6)] To have the ability to interpret itself, to allow chain semantics to
  be modified on-the-fly, on-the-chain.
\end{itemize}

The design-choices we made with \rad are:
\begin{itemize}
\item[(a)] It's a high-level, homoiconic LISP dialect.
\item[(b)] It has the ability to redefine a special function \texttt{eval}, which
  is used as part of its own evaluation.
\item[(c)] It has first-class functions.
\item[(d)] It's dynamically typed.
\item[(e)] It's lexically scoped with a `hyperstatic' global environment.
\item[(f)] It only has immutable values.
\item[(g)] It's has deterministic effect system for managing state (references).
\end{itemize}

LISP is well-known for being a high-level language having very concise
interpreters of itself, and the Scheme specification have boiled down the
semantics to a small core. Choosing a LISP helps with (2), (4) and (6), and in
particular basing the design on Scheme helps with (5).

The redefinition of \texttt{eval} is what enables (3).

Languages with first-class functions are particularly expressive, so (c) helps
with (4).

Point (d) is a compromise: it is hard to satisfy the other points (escpecially
(6)) with strong static types, even though this would help with (4). We might
try to add types in the future, but this would also inhibit the ability to
compile other-languages into \rad.

The \emph{hyperstatic} global environment means that the resolution of free
variables takes place at the definition site rather than call-site. See Section
\ref{s:hyperstatic} for explanations for how this helps with (5').

The language is kept as pure and immutable as possible, which limits
expressivity but emphasizes clarity and correctness (goal (4)). The abundance of
mutability would also probably hinder (5').

Since chains are inherantly stateful, we felt that the inclusion of a reference
type for managing state would help in the specification of chain semantics.
However we will discuss the alternatives.

The rest of this section goes into the details of these goals and
design-choices.

%% \rad is a a Lisp dialect. It uses prefix parenthesized function application,
%% supports recursion, has first-class functions, is dynamically typed, and
%% homoiconic. It differs from most Lisps in a few aspects, described below.

%% Like most Lisps, binding is lexical. Unlike most Lisps, Like Clojure, \rad
%% emphasises immutability, and mutable values must be created, read, or written
%% with specific functions (\texttt{ref}, \texttt{read-ref}, and
%% \texttt{write-ref}, respectively).

\subsection{LISP}

A minimal Scheme has the particularity that a minimal interpreter of itself can
be implemented in a few lines of code. This is acheived by:
\begin{itemize}
  \item Code being represented by the core data-structures of the language.
  \item The language being built up by a very small set of primitives: a few
    special forms and some primitive functions.
\end{itemize}
Let's consider a basic example of a chain which might want to change a part of
its semantics. In chain $C$ participants may \texttt{boot} certain other
participants, if some condition is met, which is defined by a predicate
\texttt{bootable?}. For example, \texttt{bootable?} might be defined as:
\begin{verbatim}
(define bootable?
  (lambda (a p)
    (and (admin? a) (not (admin? b)))))
\end{verbatim}
That is, admins may boot non-admins. At some point the participants may decide
that this is too crude, and that a participant should only be booted if the
majority of participants agree. For the change to take place, most likely one of
the inputs to the system will contain code for a redefintion of
\texttt{bootable?} (the semantics of when such a message is to be accepted would
probably be defined by yet another predicate). This code must be transmited and
interpreted in the most simple and transparent way possible. By choosing a LISP,
this code is carried by simple data-structures and the interpretation process is
very direct (skipping parsers, complicated abstract syntax trees, etc.). This
gives the participants better confidence in understanding what the current and
proposed semantics are.

\subsection{Hyperstatic Environments}
\label{s:hyperstatic}

Most scripting languages are intended for programs where the developer can
decide exactly where code should be placed, and be fully aware of the context
that precedes it. One can always add a line \texttt{y = bar(x)} immediately
\textit{after} \texttt{x = foo(3)}, and not worry that perhaps something else
was added in between that changes what \texttt{x} is (excepting pathological
cases of distributed code collaboration).

This is not true in the environment \rad is intended to run. In that
environment, users submit individual expressions or declarations to a running
system that is \emph{at the same time} also accepting inputs from other
users. Moreover, the view of the program that the submitter has at the time of
submission may \emph{already} be outdated. This aspect is even more significant
in the context of a blockchain, where expressions are queued until a block is
created by a node, but what those expressions in the queue are is not
accessible to other nodes.

This fact may lead to bugs or attacks. Consider the following snippet:

\begin{verbatim}
(define transfer (lambda (from to amount) ...))
(define account-alice ...)
(define account-bob ...)
(define transfer-to-alice (lambda (from amount)
  (transfer from account-alice amount))
\end{verbatim}

A user now wants to transfer some amount to Alice. However, in a language such
as Scheme the function call \texttt{(transfer-to-alice account-bob 10)} may
behave differently than this snippet alone indicates in two ways. First,
\texttt{transfer-to-alice} and \texttt{account-bob}, which explicitly appear in
the expression being submitted, may be shadowed by a new definition. Second,
the variables \texttt{transfer}, \texttt{account-alice}, and \emph{any other}
variables used in the body of \texttt{transfer} or transitively, in the
function bodies of the functions \texttt{transfer} calls, may have been
redefined.

One solution is to not allow the redefinition of variables at all. This is
indeed what some smart contract languages do, and can easily be implemented in \rad
as well (see Section \ref{s:reflective-towers}). But this comes with its own
problems; one cannot define a improved version of a function that shadows the
old one, and must instead accept a more and more polluted environment (which
additionally may impact memory usage).

An alternative is to have a mechanism to make expressions invalid if any of
variables they rely on have been redefined since a specified line of code.
However, this option comes with its own problems. Consider:

\begin{verbatim}
(define x 3) ;; line 1
(define foo (lambda () x)) ;; line 2
(define x 5) ;; line 3
\end{verbatim}

The function call \texttt{(protect-at-line 2 (foo))} will fail despite having a
perfectly reasonable interpretation - namely, \texttt{(foo)} \emph{with}
\texttt{x} \emph{as if used after line 2} (i.e., with \texttt{x} being
\texttt{3}). For more complex expressions, which may rely on many variables,
this problem becomes more significant.

This reasonable interpretation is in fact precisely what hyperstatic
environments provide. \texttt{(foo)} in line 4 would, in this model, still
evaluate to \texttt{3}. The free variables of a function refer to the values of
variables \emph{when they were defined}. This is the semantics \rad adopts in
general (and can be found in some other languages, such as Forth).

Now \texttt{(protect-at-line (foo))} may be given a much simpler definition:
\texttt{(foo)} if \texttt{foo} \emph{alone} has not been redefined, and otherwise
an exception. If \texttt{x} has been redefined, that is no matter, since it
anyhow does not change the meaning of \texttt{foo}.

%%% End section

\subsection{\texttt{eval} redefinition}

\rad does not have macros. Instead, it allows for a complete redefinition of
the intepreter via redefinitions of \texttt{eval}.

\begin{verbatim}
(define eval (lambda (expr) 3)) ;;
5 ;; => 3
\end{verbatim}

This enables users to very easily define sublanguages for new chains, or amend
the language running in the current one. A simplistic key-value store may thus
be defined in only a few lines of code:

\input{out/kv0.rad-tex}

After which we have:

\begin{verbatim}
(set key1 3) ;; => ()
(get key1) ;; => 3
(+ 3 2) ;; => 'invalid-command

;; Nested expressions are not evaluated:
(set key2 (+ 3 2)) ;; => ()
(get key2) ;; => '(+ 3 2)
\end{verbatim}

% TODO: maybe move to Related Work section
\subsection{Connection to Reflective Towers}
\label{s:reflective-towers}

The \texttt{eval}-redefinition
mechanism resembles prior work on \emph{reflective towers}. A reflective
tower is an infinite sequence of interpreters (called `levels') $L_0$, $L_1$, ..., where
level $L_n$ is interpreted by $L_{n+1}$. Reflective towers allow both
\emph{reification}---the ability to inspect a computation via constructs of a
higher level---and \emph{reflection}, that is, the ability to define and enter new,
lower levels. Conceptually, \rad differs from reflective towers by only
allowing reflection. Thus, the only levels that exist are the ones programs
create. Queinnec has quipped that reflective languages ``plunge us into a world
with few laws, and hardly any gravity''\cite{Queinnec1994}; the more disciplined approach to
reflection that \rad takes does not possess the semantic fragility of modifying
meta-meta-intepreters.

The techniques that have been developed for reducing the interpretive overhead
of such towers of interpreters, however, still
apply (see, for example, \cite{Amin2017}, \cite{Asai2014}), as do simpler
partial-evaluation-based approaches such as \cite{Brown2017}.



\subsection{Effects} In order to maintain determinism and safety in on-chain
computations, and at the same time be a useful language for scripting
interactions with chains, \rad keeps a separate, \emph{impure} environment,
$\rho_{!}$ (these are by convention textually distinguished by identifiers
ending with an exclamation mark). Expressions on chain therefore cannot have
side-effects; instead, they may evaluate to a value that \emph{describes} an effect,
but the decision of whether or how to actually carry on that effect happens at an
effect-handling layer. This architecture, with a central authority
administering effects received via messages, resembles work following
\cite{Cartwright1994} and \cite{Bauer2003}.


\begin{figure}[H]
\begin{tikzpicture}[node distance = 4cm, auto]
  \node [block] (net) {Network};
  \node [block, below of=net] (repl) {REPL};
  \node [block, left of=repl] (impure) {effect handler};
  \node [block, below of=impure] (pure) {pure evaluation};
  \node [block, above of=impure] (file) {File};

    \path [line]
    (file) -- node [left] {\texttt{read-line!} $V_{n+1}$} (impure);

    \path [line, transform canvas={yshift=0.2cm}]
    (net) -- node {\texttt{gossip!} [$B_n$]} (impure);
    \path [line, transform canvas={yshift=-0.2cm}]
    (impure) -- node {\texttt{hear-gossip!} $V_{n+1}$} (net);

    \path [line, transform canvas={yshift=0.2cm}]
    (repl) -- node [above] {\texttt{get-line!} [$B_n$]} (impure);
    \path [line, transform canvas={yshift=-0.2cm}]
    (impure) -- node [below] {\texttt{print!} $V_{n+1}$} (repl);

  \path [line, transform canvas={xshift=0.2cm}]
    (impure) -- node {$S_n$, $B_n$} (pure);
  \path [line, transform canvas={xshift=-0.2cm}]
    (pure) -- node {$S_{n+1}$, $V_{n+1}$} (impure);

\end{tikzpicture}
\caption{Effect system}
\label{f:effects}
\end{figure}

The value that results from evaluating an expression purely may, in addition to
\emph{describing} an effect, pass a continuation with the result of that
effect (if any). The effect-handling layer can chose to only call continuations
without arguments. This in turn means the continuation will not have access to
the result of effectful computations, though it may (at the discretion of the
effect-handling layers) have output effects.

\begin{figure}[H]
\input{out/repl.rad-tex}
    \caption{A simple effect handler. The function \texttt{subscribe-to!}
    repeatedly calls the \texttt{getter} key of its first argument, handling
    effects with its second argument. \texttt{default-impure-handler!} handles
    effects by calling the impure function corresponding to the effect tag. If
    we remove it, keeping only \texttt{(print! x)}, we would see printed in the
    console the value that describes an effect only.}
\label{f:eff-handler}
\end{figure}

A further advantage of this approach is that, since on many blockchain
protocols new blocks have a low initial probability of being final (given the
possibility of forks), effects may be easily and programmatically delayed until
sufficiently many child blocks have been seen by simply buffering the
description of effects before passing them to the effect-handling layer.

\subsection{Data types} \rad's data types are: booleans (\texttt{\#t} and
\texttt{\#f}); strings (a sequence of characters within double quotes, with
\texttt{\textbackslash} as the escape character), symbols, lists, dictionaries
(maps), and numbers (currently only arbitrary-precision decimals). These
datatypes are all immutable; additionally \rad supports \emph{refs}--mutable
references--that can hold any other datatype.

\subsection{Syntax}


\subsection{Formal Semantics} We define the denotational semantics of \rad
recursively. The base case, $\mathcal{E}_{0}$, describes the denotation of a
term prior to any modification of \texttt{eval}. It's definition is given in
Figure \ref{f:denotationalsem0}.

\begin{figure}[H]
\begin{align*}
    Environment [\env] &= Identifier \rightarrow Value \\
    Memory [\mem] &= Address \rightarrow Value \\
    Value [\val] &= Address + Function + Boolean ... \\
    Continuation [\cont] &= Value \times Memory \rightarrow Value \\
    Function [\phi] &= Value* \times Continuation \times Memory \rightarrow Value
\end{align*}
\label{f:denotationalsemleged}
\end{figure}


\begin{figure}[H]
\begin{align*}
    \denotationdesc{0}{\variable}{(\cont (\env \variable) \mem)} \\
    \denotationdesc{0}{(\lam (\variable *)\: \pi^{+})}{
      \cont (\lambda \val * \cont_1 \mem_1 . \\
        \text{if } (\text{length } \variable *) = (\text{length } \val *) \\
        \text{then } \denotation{0}{\pi^{+}}\env[\variable * \rightarrow} \val * ] \cont_1 \mem_1 \\
        \text{else } \text{error "Wrong arity"} \\
        \text{endif } ) \mem ) \\
    \denotationdesc{0}{(\define \: \variable \: \pi )}{
      \denotation{0}{\pi}\env \lambda \val
    } \\
    \denotationdesc{0}{(\deref \: \variable  )}{\cont (\mem (\texttt{projAddr}(\env \variable)))) \mem} \\
  \denotationdesc{0}{(\mkref \: \variable \: \pi)}{} \\
  \denotationdesc{0}{(\writeref \: \variable \: \pi)}{
      \denotation{0}{\pi} \lambda \val \mem_1 . (\cont \val \mem_1 [(\env
      \variable) \rightarrow \val]) \mem } \\
  \denotationdesc{0}{(\ifm \: \pi_0 \: \pi_1 \: \pi_2)}{\denotation{0}{\pi_0}\env
    \lambda \val \mem_1 .(\text{if } \val  \\
    \text{then } \denotation{0}{\pi_1}  \\
    \text{else } \denotation{0}{\pi_2} \\
    \text{endif } \env \cont \mem_1)  \mem ) } \\
  \denotationdesc{0}{(\pi \pi+ )}{
      \denotation{0}{\pi_0}\env \lambda \val \mem_1 . (\denotation{0}{\pi+}
      \env \cont \mem_1) \mem
  }
\end{align*}
\caption{Denotational semantics for $\mathcal{E}_{0}$}
\label{f:denotationalsem0}
\end{figure}

After a redefinition of \texttt{eval}, the denotation of an expression is the
denotation of \texttt{eval} prior to the redefinition, applied to the
\emph{quoted} expression, as show in Figure \ref{f:denotationalsemn}.

\begin{figure}[H]
\begin{align*}
  \denotationdesc{n}{\pi}{(\denotation{n-1}{\evalm} (\quotem \pi))\env\cont\mem}
\end{align*}
\caption{Denotational semantics for $\mathcal{E}_{n}$}
\label{f:denotationalsemn}
\end{figure}

Besides the forms described so far, additional forms exist which may be
implemented via \texttt{eval} redefinitions. They may also be implemented as
primitives; in either case, these forms must not be shadowable via
\texttt{define}s.
