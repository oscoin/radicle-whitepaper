\section{Language Syntax and Semantics}
\label{s:language}

Technologically speaking, \rad doesn't bring anything new to programming
language design. It is essentially a specific point in the design-space (and
related tooling) optimized for the following goals:
\begin{itemize}
\item[(1)] To be deterministic, so that \rad programs specifiy deterministic
  state machines.
\item[(2)] To be powerful enough to be a `universal state-machine'.
\item[(3)] To be able to restrict this power appropirately, so that malicious
  inputs can be rejected.
\item[(4)] To be concise, expressive and emphesize correctness, so that new
  chains, with new semantics can be created cheaply (in terms of development
  time), be easily understood by all participants, and hopefully be bug-free.
\item[(5')] To work well in a collaborative setting, which code being submitted
  by multiple parties in a potentially unspecified order.
\item[(5)] To have as simple as possible underlying underlying semantics, so
  that \rad interpreters are well specified, and so that \rad can be used in
  security sensitive situations.
\item[(6)] To have the ability to interpret itself, to allow chain semantics to
  be modified on-the-fly, on-the-chain.
\end{itemize}

The design-choices we made with \rad are:
\begin{itemize}
\item[(a)] It's a high-level, homoiconic LISP dialect.
\item[(b)] It has the ability to redefine a special function \texttt{eval}, which
  is used as part of its own evaluation.
\item[(c)] It has first-class functions.
\item[(d)] It's dynamically typed.
\item[(e)] It's lexically scoped with a `hyperstatic' global environment.
\item[(f)] It only has immutable values.
\item[(g)] It's has deterministic effect system for managing state (references).
\end{itemize}

LISP is well-known for being a high-level language having very concise
interpreters of itself, and the Scheme specification have boiled down the
semantics to a small core. Choosing a LISP helps with (2), (4) and (6), and in
particular basing the design on Scheme helps with (5).

The redefinition of \texttt{eval} is what enables (3).

Languages with first-class functions are particularly expressive, so (c) helps
with (4).

Point (d) is a compromise: it is hard to satisfy the other points (escpecially
(6)) with strong static types, even though this would help with (4). We might
try to add types in the future, but this would also inhibit the ability to
compile other-languages into \rad.

The \emph{hyperstatic} global environment means that the resolution of free
variables takes place at the definition site rather than call-site. See Section
\ref{s:hyperstatic} for explanations for how this helps with (5').

The language is kept as pure and immutable as possible, which limits
expressivity but emphasizes clarity and correctness (goal (4)). The abundance of
mutability would also probably hinder (5').

Since chains are inherantly stateful, we felt that the inclusion of a reference
type for managing state would help in the specification of chain semantics.
However we will discuss the alternatives.

The rest of this section goes into the details of these goals and
design-choices.

%% \rad is a a Lisp dialect. It uses prefix parenthesized function application,
%% supports recursion, has first-class functions, is dynamically typed, and
%% homoiconic. It differs from most Lisps in a few aspects, described below.

%% Like most Lisps, binding is lexical. Unlike most Lisps, Like Clojure, \rad
%% emphasises immutability, and mutable values must be created, read, or written
%% with specific functions (\texttt{ref}, \texttt{read-ref}, and
%% \texttt{write-ref}, respectively).


\subsection{LISP}

A minimal Scheme has the particularity that a minimal interpreter of itself can
be implemented in a few lines of code. This is acheived by:
\begin{itemize}
  \item Code being represented by the core data-structures of the language.
  \item The language being built up by a very small set of primitives: a few
    special forms and some primitive functions.
\end{itemize}
Let's consider a basic example of a chain which might want to change a part of
its semantics. In chain $C$ participants may \texttt{boot} certain other
participants, if some condition is met, which is defined by a predicate
\texttt{bootable?}. For example, \texttt{bootable?} might be defined as:
\begin{verbatim}
(define bootable?
  (lambda (a p)
    (and (admin? a) (not (admin? b)))))
\end{verbatim}
That is, admins may boot non-admins. At some point the participants may decide
that this is too crude, and that a participant should only be booted if the
majority of participants agree. For the change to take place, most likely one of
the inputs to the system will contain code for a new version of
\texttt{bootable?} (the semantics of when such a message is to be accepted would
probably be defined by yet another predicate). This code must be transmited and
interpreted in the most simple and transparent way possible. By choosing a LISP,
this code is carried by simple data-structures and the interpretation process is
very direct (skipping parsers, complicated abstract syntax trees, etc.). This
gives the participants better confidence in understanding what the current and
proposed semantics are.

\subsection{Hyperstatic Environments}
\label{s:hyperstatic}

Most scripting languages are intended for programs where the developer can
decide exactly where code should be placed, and be fully aware of the context
that precedes it. One can always add a line \texttt{y = bar(x)} immediately
\emph{after} \texttt{x = foo(3)}, and not worry that perhaps something else was
added in between that changes what \texttt{x} is (excepting pathological cases
of distributed code collaboration).

This is not true in the environment \rad is intended to run. In that
environment, users submit individual expressions or declarations to a running
system that is \emph{at the same time} also accepting inputs from other
users. Moreover, the view of the program that the submitter has at the time of
submission may \emph{already} be outdated. This aspect is even more significant
in the context of a blockchain, where expressions are queued until a block is
created by a node, but what those expressions in the queue are is not
accessible to other nodes.

This fact may lead to bugs or attacks. Consider the following snippet:

\begin{verbatim}
(define transfer (lambda (from to amount) ...))
(define account-alice ...)
(define account-bob ...)
(define transfer-to-alice (lambda (from amount)
  (transfer from account-alice amount))
\end{verbatim}

A user now wants to transfer some amount to Alice. However, in a language such
as Scheme the function call \texttt{(transfer-to-alice account-bob 10)} may
behave differently than this snippet alone indicates in two ways. First,
\texttt{transfer-to-alice} and \texttt{account-bob}, which explicitly appear in
the expression being submitted, may be shadowed by a new definition. Second, the
variables \texttt{transfer}, \texttt{account-alice}, and \emph{any other} free
variables used in the body of \texttt{transfer} or transitively, in the function
bodies of the functions \texttt{transfer} calls, may have been redefined.

One solution is to not allow the redefinition of variables at all. This is
indeed what some smart contract languages do, and can easily be implemented in
\rad as well (see Section \ref{s:reflective-towers}). But this comes with its
own problems; one cannot define an improved version of a function that shadows
the old one, and must instead accept a more and more polluted environment (which
additionally may impact memory usage).

An alternative is to have a mechanism to make expressions invalid if any of the
variables they rely on have been redefined since a specified line of code.
However this option is quite severe. Consider:

\begin{verbatim}
(define x 3) ;; line 1
(define foo (lambda () x)) ;; line 2
(define x 5) ;; line 3
\end{verbatim}

The function call \texttt{(protect-at-line 2 (foo))} will fail despite having a
perfectly reasonable interpretation - namely, \texttt{(foo)} \emph{with}
\texttt{x} \emph{as if used after line 2} (i.e., with \texttt{x} being
\texttt{3}). For more complex expressions, which may rely on many variables,
this problem becomes more significant.

This reasonable interpretation is in fact precisely what hyperstatic
environments provide. The function call \texttt{(foo)} in line 4 would, in this
model, still evaluate to \texttt{3}. The free variables of a function refer to
the values of variables \emph{when they were defined}. This is the semantics
\rad adopts in general (and can be found in some other languages, such as
Forth).

Now \texttt{(protect-at-line (foo))} may be given a much simpler definition:
\texttt{(foo)} if \texttt{foo} \emph{alone} has not been redefined, and otherwise
an exception. If \texttt{x} has been redefined, that is no matter, since it
anyhow does not change the meaning of \texttt{foo}.

%%% End section

\subsection{\texttt{eval} redefinition}

\rad should be able to emulate any state machine. Of course most state-machines
don't accept arbitrary inputs, and certainly not inputs which change the
semantics of the state-machine. Thus \rad should have some built in mechanism
for controlling how inputs get interpreted. At the start inputs are sent
directly for evaluation by the `base' evaluator, so it's natural to associate
modifying this process with redefining a function which represents evaluation.
When taken to the extreme, \emph{all} evaluation is done with a call to the
special function \texttt{eval}, and this creates a reflective tower of
interpreters. In \rad, a more limited form of \texttt{eval}-redefinition is
available, which only takes effect on the next input. As an example:
\begin{verbatim}
> (define eval (lambda (expr) 3))
=> ()
> 5
=> 3
\end{verbatim}

Contrast this with the sort of \texttt{eval}-redefinition that is available in the language Black:
\begin{verbatim}
(exec-at-metalevel
  (let ((old-eval base-eval))
    (set! base-eval
          (lambda (exp env cont)
            (write exp) (newline) (old-eval exp env cont)))))
\end{verbatim}
After this the Black REPL will behave as follows:
\begin{verbatim}
> (+ 1 2)
(+ 1 2)
+
1
2
=> 3
\end{verbatim}
Note in particular that the new evaluation function is used recursively, at all
levels of the expression \texttt{(+ 1 2)}.

Compare this to the following \rad session:
\begin{verbatim}
rad> (define eval (lambda (e) (do (print! e) (eval e))))
=> ()
rad> (+ 1 2)
(+ 1.0 2.0)
=> 3.0
\end{verbatim}
First of all note that we do not need to create a binding to the previous
version of eval; because of the hyperstatic environment the symbol \texttt{eval}
in the new definition of \texttt{eval} always refers to the old version of the
evaluation function. Second, in Black, \texttt{old-eval} calls out to
\texttt{base-eval}, and in subsequent evaluation this will refer to the new
definition. This is what makes the new evalution behaviour take effect at all
levels of evaluation. In \rad, the new evaluation only gets invoked at the
topmost level, on new inputs. If one wants to make the evaluation behaviour
recursive this has to be coded explicitely.

In most cases chains will define a domain-specific language to be interpreted in
some narrow way, with only some calls to the base eval to reify function
definitions, in case one wants to modify the behaviour of the state-machine in
some way. Furthermore, this form of evaluation redefinition doesn't (by default)
create a tower of interpreters. Evaluating in a towers requires advanced
interpretation methods otherwise performance suffers greatly, and this is all
the more important in \rad's case where chains may be very long-lived. Such
methods are still the subject of active reasearch, and may interfere with other
requirements of the language. For these reasons we beleive that this limited
form of eval-redefinition suits the needs of \rad better than the sort of
reflection that can be found in languages such as black.

%% \rad does not have macros. Instead, it allows for a complete redefinition of
%% the intepreter via redefinitions of \texttt{eval}.

%% \begin{verbatim}
%% (define eval (lambda (expr) 3)) ;;
%% 5 ;; => 3
%% \end{verbatim}

%% This enables users to very easily define sublanguages for new chains, or amend
%% the language running in the current one.

For a more involved example, consider a simplistic key-value store:

\input{out/kv0.rad-tex}

After which we have:

\begin{verbatim}
> (set key1 3)
=> ()
> (get key1)
=> 3
> (+ 3 2)
=> 'invalid-command

;; Note that nested expressions are not evaluated:
> (set key2 (+ 3 2))
=> ()
> (get key2)
=> '(+ 3 2)
\end{verbatim}

% TODO: maybe move to Related Work section
\subsection{Connection to Reflective Towers}
\label{s:reflective-towers}

The \texttt{eval}-redefinition mechanism resembles prior work on
\emph{reflective towers}. A reflective tower is an infinite sequence of
interpreters (called `levels') $L_0$, $L_1$, ..., where level $L_n$ is
interpreted by $L_{n+1}$. Reflective towers allow both \emph{reification}---the
ability to inspect a computation via constructs of a higher level---and
\emph{reflection}, that is, the ability to define and enter new, lower levels.
Conceptually, \rad differs from reflective towers by only allowing reflection.
Thus, the only levels that exist are the ones programs create. Queinnec has
quipped that reflective languages ``plunge us into a world with few laws, and
hardly any gravity''\cite{Queinnec1994}; the more disciplined approach to
reflection that \rad takes does not possess the semantic fragility of modifying
meta-meta-intepreters.

The techniques that have been developed for reducing the interpretive overhead
of such towers of interpreters, however, still
apply (see, for example, \cite{Amin2017}, \cite{Asai2014}), as do simpler
partial-evaluation-based approaches such as \cite{Brown2017}.

\subsection{Immutable values and refs}
In \rad all values are immutable: once created they cannot be modified in any
way. This follows in the footsteps of languages such as functional programming
languages such as Haskell, Clojure, Erlang, etc.

TODO: talk about how this leads to more correctness, and also how mutation would
be all the more confusing in a collaborative coding environment (same sort of
arguments as why mutation is hard in multi-threaded code).

However state-machines are inherantly stateful, so a reference type is included
in the language.

TODO: explain

Other things we might have consider, or might consider in the future: Another
possibility is to have an single implicit global state (essentially a single
predefined ref), and for computations with this state to be formulated using a
state-monad. Having only a single location for holding state might encumber the
developer, but providing a nice interface to state manipulation using lenses
might make this a viable option.


\subsection{Effects} In order to maintain determinism and safety in on-chain
computations, and at the same time be a useful language for scripting
interactions with chains, \rad keeps a separate, \emph{impure} environment,
$\rho_{!}$ (these are by convention textually distinguished by identifiers
ending with an exclamation mark). Expressions on chain therefore cannot have
side-effects; instead, they may evaluate to a value that \emph{describes} an effect,
but the decision of whether or how to actually carry on that effect happens at an
effect-handling layer. This architecture, with a central authority
administering effects received via messages, resembles work following
\cite{Cartwright1994} and \cite{Bauer2003}.


\begin{figure}[H]
\begin{tikzpicture}[node distance = 4cm, auto]
  \node [block] (net) {Network};
  \node [block, below of=net] (repl) {REPL};
  \node [block, left of=repl] (impure) {effect handler};
  \node [block, below of=impure] (pure) {pure evaluation};
  \node [block, above of=impure] (file) {File};

    \path [line]
    (file) -- node [left] {\texttt{read-line!} $V_{n+1}$} (impure);

    \path [line, transform canvas={yshift=0.2cm}]
    (net) -- node {\texttt{gossip!} [$B_n$]} (impure);
    \path [line, transform canvas={yshift=-0.2cm}]
    (impure) -- node {\texttt{hear-gossip!} $V_{n+1}$} (net);

    \path [line, transform canvas={yshift=0.2cm}]
    (repl) -- node [above] {\texttt{get-line!} [$B_n$]} (impure);
    \path [line, transform canvas={yshift=-0.2cm}]
    (impure) -- node [below] {\texttt{print!} $V_{n+1}$} (repl);

  \path [line, transform canvas={xshift=0.2cm}]
    (impure) -- node {$S_n$, $B_n$} (pure);
  \path [line, transform canvas={xshift=-0.2cm}]
    (pure) -- node {$S_{n+1}$, $V_{n+1}$} (impure);

\end{tikzpicture}
\caption{Effect system}
\label{f:effects}
\end{figure}

The value that results from evaluating an expression purely may, in addition to
\emph{describing} an effect, pass a continuation with the result of that
effect (if any). The effect-handling layer can chose to only call continuations
without arguments. This in turn means the continuation will not have access to
the result of effectful computations, though it may (at the discretion of the
effect-handling layers) have output effects.

\begin{figure}[H]
\input{out/repl.rad-tex}
    \caption{A simple effect handler. The function \texttt{subscribe-to!}
    repeatedly calls the \texttt{getter} key of its first argument, handling
    effects with its second argument. \texttt{default-impure-handler!} handles
    effects by calling the impure function corresponding to the effect tag. If
    we remove it, keeping only \texttt{(print! x)}, we would see printed in the
    console the value that describes an effect only.}
\label{f:eff-handler}
\end{figure}

A further advantage of this approach is that, since on many blockchain
protocols new blocks have a low initial probability of being final (given the
possibility of forks), effects may be easily and programmatically delayed until
sufficiently many child blocks have been seen by simply buffering the
description of effects before passing them to the effect-handling layer.

\subsection{Data types} \rad's data types are: booleans (\texttt{\#t} and
\texttt{\#f}); strings (a sequence of characters within double quotes, with
\texttt{\textbackslash} as the escape character), symbols, lists, dictionaries
(maps), and numbers (currently only arbitrary-precision decimals). These
datatypes are all immutable; additionally \rad supports \emph{refs}--mutable
references--that can hold any other datatype.

\subsection{Syntax}

% new semantics

The base semantics of \rad is easy to define and is similar like that of a normal
scheme.

TODO: insert normal scheme semantics here, but with hyperstatic, etc. Note that
sequences will be defined by the auxilary semantics $E^+$. This is
not how \emph{toplevel} sequences are processed.

For a sequence of toplevel inputs, we define a new sequence denotation
$E_n^I$ where $E_0^I = E$.

Then:
\[
E_n(\pi) = E_{n-1} (\mathtt{( eval (quote \pi))}) \env\cont\mem
\]

% old semantics

\subsection{Formal Semantics} We define the denotational semantics of \rad
recursively. The base case, $\mathcal{E}_{0}$, describes the denotation of a
term prior to any modification of \texttt{eval}. It's definition is given in
Figure \ref{f:denotationalsem0}.

\begin{figure}[H]
\begin{align*}
    Environment [\env] &= Identifier \rightarrow Value \\
    Memory [\mem] &= Address \rightarrow Value \\
    Value [\val] &= Address + Function + Boolean ... \\
    Continuation [\cont] &= Value \times Memory \rightarrow Value \\
    Function [\phi] &= Value* \times Continuation \times Memory \rightarrow Value
\end{align*}
\label{f:denotationalsemleged}
\end{figure}


\begin{figure}[H]
\begin{align*}
    E_desc{0}{\variable}{(\cont (\env \variable) \mem)} \\
    \denotationdesc{0}{(\lam (\variable *)\: \pi^{+})}{
      \cont (\lambda \val * \cont_1 \mem_1 . \\
        \text{if } (\text{length } \variable *) = (\text{length } \val *) \\
        \text{then } \denotation{0}{\pi^{+}}\env[\variable * \rightarrow} \val * ] \cont_1 \mem_1 \\
        \text{else } \text{error "Wrong arity"} \\
        \text{endif } ) \mem ) \\
    \denotationdesc{0}{(\define \: \variable \: \pi )}{
      \denotation{0}{\pi}\env \lambda \val
    } \\
    \denotationdesc{0}{(\deref \: \variable  )}{\cont (\mem (\texttt{projAddr}(\env \variable)))) \mem} \\
  \denotationdesc{0}{(\mkref \: \variable \: \pi)}{} \\
  \denotationdesc{0}{(\writeref \: \variable \: \pi)}{
      \denotation{0}{\pi} \lambda \val \mem_1 . (\cont \val \mem_1 [(\env
      \variable) \rightarrow \val]) \mem } \\
  \denotationdesc{0}{(\ifm \: \pi_0 \: \pi_1 \: \pi_2)}{\denotation{0}{\pi_0}\env
    \lambda \val \mem_1 .(\text{if } \val  \\
    \text{then } \denotation{0}{\pi_1}  \\
    \text{else } \denotation{0}{\pi_2} \\
    \text{endif } \env \cont \mem_1)  \mem ) } \\
  \denotationdesc{0}{(\pi \pi+ )}{
      \denotation{0}{\pi_0}\env \lambda \val \mem_1 . (\denotation{0}{\pi+}
      \env \cont \mem_1) \mem
  }
\end{align*}
\caption{Denotational semantics for $\mathcal{E}_{0}$}
\label{f:denotationalsem0}
\end{figure}

After a redefinition of \texttt{eval}, the denotation of an expression is the
denotation of \texttt{eval} prior to the redefinition, applied to the
\emph{quoted} expression, as show in Figure \ref{f:denotationalsemn}.

\begin{figure}[H]
\begin{align*}
  \denotationdesc{n}{\pi}{(\denotation{n-1}{\evalm} (\quotem \pi))\env\cont\mem}
\end{align*}
\caption{Denotational semantics for $\mathcal{E}_{n}$}
\label{f:denotationalsemn}
\end{figure}

Besides the forms described so far, additional forms exist which may be
implemented via \texttt{eval} redefinitions. They may also be implemented as
primitives; in either case, these forms must not be shadowable via
\texttt{define}s.
