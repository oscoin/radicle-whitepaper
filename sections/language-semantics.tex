\section{Language Syntax and Semantics}
\label{s:language}

\rad is a a Lisp dialect. It uses prefix parenthesized function application,
supports recursion, has first-class functions, is dynamically typed, and
homoiconic. It differs from most Lisps in a few aspects, described below.

Like most Lisps, binding is lexical. Unlike most Lisps, \rad has a
\textit{hyperstatic} global environment, meaning that the resolution of free
variables takes place at the definition site rather than call-site. Thus:

\begin{verbatim}
(define (foo) x) ;; error - "x" is not defined
(define x 3)
(foo) ;; 3
(define x 5)
(foo) ;; still 3
\end{verbatim}

Usually \rad programs are an interleaving of code written by multiple people,
and each developer cannot in general be certain of what code will end up in the
program between the text that she knows about and her new submission. A
hyperstatic environment ameliorates the resulting unpredictability by making
function calls by default (i.e., modulo the usage of mutable references)
independent of intermediate submissions.

\rad does not have macros. Instead, it allows for a complete redefinition of
the intepreter via redefinitions of \texttt{eval}.

\begin{verbatim}
(define (eval expr) 3) ;;
5 ;; --> 3
\end{verbatim}

This enables users to very easily define sublanguages for new chains, or amend
the language running in the current one.

% TODO: maybe move to Related Work section
\subsection{Connection to Reflective Towers} The \texttt{eval}-redefinition
mechanism resembles prior work on \textit{reflective towers}. A reflective
tower is an infinite series of levels of interpreters, $L_0$, $L_1$, ..., where
a level $L_n$ is interpreted by $L_{n+1}$. Reflective towers allow both
\textit{reification} - the ability to inspect a computation via constructs of a
higher level - and \textit{reflection} - the ability to define and enter new,
lower levels. Conceptually, \rad differs from reflective towers by only
allowing reflection. You can dig a hole, but don't expect to find an elevator
out of it.

\subsection{Effects} In order to maintain determinism and safety in on-chain
computations, and at the same time be a useful language for scripting
interactions with chains, \rad keeps a separate, \textit{impure} environment,
$\rho_{!}$ (these are by convention textually distinguished by identifiers
ending with an exclamation mark). Expressions on chain therefore cannot have
side-effects; instead, they may evaluate to a value that \textit{describes} an effect,
but the decision of whether or how to actually carry on that effect happens at
effect-handling layer. This architecture, with a central authority
administering effects received via messages, resembles work following
\cite{Cartwright1994} and \cite{Bauer2003}.


\begin{figure}[H]
\begin{tikzpicture}[node distance = 4cm, auto]
  \node [block] (net) {Network};
  \node [block, below of=net] (repl) {REPL};
  \node [block, left of=repl] (impure) {effect handler};
  \node [block, below of=impure] (pure) {pure evaluation};
  \node [block, above of=impure] (file) {File};

    \path [line]
    (file) -- node [left] {\texttt{read-line!} $V_{n+1}$} (impure);

    \path [line, transform canvas={yshift=0.2cm}]
    (net) -- node {\texttt{gossip!} [$B_n$]} (impure);
    \path [line, transform canvas={yshift=-0.2cm}]
    (impure) -- node {\texttt{hear-gossip!} $V_{n+1}$} (net);

    \path [line, transform canvas={yshift=0.2cm}]
    (repl) -- node [above] {\texttt{get-line!} [$B_n$]} (impure);
    \path [line, transform canvas={yshift=-0.2cm}]
    (impure) -- node [below] {\texttt{print!} $V_{n+1}$} (repl);

  \path [line, transform canvas={xshift=0.2cm}]
    (impure) -- node {$S_n$, $B_n$} (pure);
  \path [line, transform canvas={xshift=-0.2cm}]
    (pure) -- node {$S_{n+1}$, $V_{n+1}$} (impure);

\end{tikzpicture}
\caption{Effect system}
\label{f:effects}
\end{figure}

The value that results from evaluating an expression purely may, in addition to
\textit{describing} an effect, pass a continuation with the result of that
effect (if any). The effect-handling layer can chose to only call continuations
without arguments. This in turn means the continuation will not have access to
the result of effectful computations, though it may (at the discretion of the
effect-handling layers) have output effects.

\begin{figure}[H]
\begin{verbatim}

(define repl
  (sorted-map
    name "repl"
    getter (quote (get-line!))))

(subscribe-to! repl
  (lambda (x)
    (print! (default-impure-handler! x))))

\end{verbatim}
    \caption{A simple effect handler. The function \texttt{subscribe-to!}
    repeatedly calls the \texttt{getter} key of its first argument, handling
    effects with its second argument. \texttt{default-impure-handler!} handles
    effects by calling the impure function corresponding to the effect tag. If
    we remove it, keeping only \texttt{(print! x)}, we would see printed in the
    console the value that describes an effect only.}
\label{f:eff-handler}
\end{figure}

A further advantage of this approach is that, since on many blockchain
protocols new blocks have a low initial probability of being final (given the
possibility of forks), effects may be easily and programmatically delayed until
sufficiently many child blocks have been seen by simply buffering the
description of effects before passing them to the effect-handling layer.

\subsection{Data types} \rad's data types are: booleans (\texttt{\#t} and
\texttt{\#f}); strings (a sequence of characters within double quotes, with
\texttt{\textbackslash} as the escape character), symbols, lists, and numbers
(currently only arbitrary-precision decimals). These datatypes are all
immutable; additionally \rad supports \textit{refs} - mutable references - that
can hold any other datatype. Refs support a similar set of operations to
Clojure's atoms; however, they are not shareable across threads, and can be
interpreted as a pure state transformer.\footnote{The reference implementation
of \rad in fact uses Haskell's \texttt{STRef}s to implement refs, which in turn
use a by now well-known rank-2 type encapsulation to guarantee the property of
not being shareable across threads.\cite{lazy-functional-state-threads}}

\subsection{Syntax}


\subsection{Formal Semantics} We define the denotational semantics of \rad
recursively. The base case, $\mathcal{E}_{0}$, describes the denotation of a
term prior to any modification of \texttt{eval}. It's definition is given in
Figure \ref{f:denotationalsem0}.


\begin{figure}[H]
\begin{align*}
  \denotationdesc{0}{\variable}{\env \variable} \\
  \denotationdesc{0}{(\lam (\variable *) \rho^{+})}{} \\
  \denotationdesc{0}{(\define \variable \pi )}{} \\
  \denotationdesc{0}{(\deref \variable  )}{} \\
  \denotationdesc{0}{(\mkref \variable \pi)}{} \\
  \denotationdesc{0}{(\set \variable \pi)}{} \\
  \denotationdesc{0}{(\ifm \pi_0 \pi_1 \pi_2)}{}
\end{align*}
\caption{Denotational semantics for $\mathcal{E}_{0}$}
\label{f:denotationalsem0}
\end{figure}

After a redefinition of \texttt{eval}, the denotation of an expression is the
denotation of \texttt{eval} prior to the redefinition, applied to the
\textit{quoted} expression, as show in Figure \ref{f:denotationalsemn}.

\begin{figure}[H]
\begin{align*}
  \denotationdesc{n}{\pi}{(\denotation{n-1}{\evalm} (\quotem \pi))\rho}
\end{align*}
\caption{Denotational semantics for $\mathcal{E}_{n}$}
\label{f:denotationalsemn}
\end{figure}

Besides the forms described so far, additional forms exist which may be
implemented via \texttt{eval} redefinitions. They may also be implemented as
primitives; in either case, these forms must not be shadowable via
\texttt{define}s.
