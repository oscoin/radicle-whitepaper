\section{Light-client Protocol}

To enable so-called \emph{light-clients}---clients that do not carry the full
state of the block-tree---to transact securely on the block-tree, we specify a
`light-client protocol' which is able to perform verified lookups as well as
perform operations on the global ledger.

In general, users of the protocol will be light-clients unless they perform
replica duties. The idea of a light-client is \emph{trustless verification}:
since we are operating in an adversarial setting, clients have the ability to
require proofs from the replicas they interact with, that the data being served
is authentic. Clients transacting with nodes are then able to locally verify
these proofs, guaranteeing that they are operating with valid data. Example
usecases fo the light-client protocol are wallets, issue resolution, etc.

\subsection{Overview}

In \oscoin{}, light-client proofs operates within the \emph{three-party}
model~\ref{three-party-model}, which involves an untrusted prover (the
replica), a verifier (the light-client), and a trusted source (the block-tree).
The light-client is able to request the value of any key in the state $\state$,
and the replica responds with proofs of existence or absence of these keys, that
the client can verify locally against a digest provided by the trusted source.

\subsection{Implementation}

To enable light-client proofs, we implement our state $\state$ as an
authenticated dictionary~\ref{auth-dictionary} from which proofs of key and
associated value existence or absence can be derived.

Our particular data-structure is a merkelized AVL+ tree~\ref{avl-tree} which
allows proofs in $\mathcal{O}(\log n)$ time and space to be constructed. These
merkle proofs represent authenticated paths to the keys requested in the client.

\subsection{Light-client operations}

Light-client operations can be categorized as either querying the value under a
certain key in $\state$, or submitting a signed transaction to the ledger
$\ledger$.

\subsubsection{Querying state}

When querying, the prover provides a proof that $\state$ includes a certain key
$k$ at a given height $h$ and that the value $v$ under it is what it says it
is. This can be checked against the state hash $\hash(\state_h)$ included in the
block header at height $h$. We define this operation formally as
\[
    lookup(k) = \begin{cases}
        (v, \Pi(k, v))     & \text{if} \quad k \in \state_h \\
        \Pi(k)             & \text{otherwise}
    \end{cases}
\]
where $\Pi$ returns a merkle proof of existence or absence of a key or
key/value pair.

\subsubsection{Submitting transactions}

When submitting a transaction, the client is interested in knowing that the
transaction in question is included in a block in the ledger $\ledger$. This
works identically to verifying key inclusion in $\state$, but with a different
underlying data-structure. The hash the client is interested in here is the
transaction root hash $H_{tr}$. We define this operation formally as
\[
    submit(tx) = \Pi(tx, h)
\]

\subsection{The AVL+ tree}

The choice of data-structure to represent the state $\state$ comes from two
constraints.  On the one hand we look for a data-structure which can produce
small proofs ($\mathcal{O}(\log n)$), and on the other hand we look for one
which can be altered without recomputing the entire data-structure. Traditional
merkle trees as used in Bitcoin~\ref{bitcoin-merkle-tree} satisfy the first
criteria, but not the second, while Particia Tries~\ref{patricia-trie} as used
in Ethereum fulfill the second criteria but not the first.
